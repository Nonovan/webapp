"""
Vulnerability Model for Cloud Infrastructure Platform.

This module provides a modernized data model for tracking and managing security
vulnerabilities across the platform. It implements the complete vulnerability
lifecycle management from discovery to remediation or risk acceptance.

The model supports integration with security scanning tools, threat intelligence
feeds, and incident management components, providing a comprehensive view of
the organization's vulnerability landscape.

Features:
- Comprehensive vulnerability tracking with CVE and custom vulnerability support
- CVSS scoring and severity classification with vector string parsing
- Risk-based prioritization with configurable parameters
- Remediation management with SLA tracking and deadline enforcement
- Integration with security scanning and threat intelligence
- Support for compliance tracking with regulatory frameworks
- Advanced filtering and statistical analysis capabilities
- Audit logging and historical tracking of vulnerability lifecycle
"""

import json
import re
from datetime import datetime, timezone, timedelta
from typing import Dict, List, Any, Optional, Union, Tuple, Set
from sqlalchemy import func, case, desc, and_, or_, not_, text
from sqlalchemy.dialects.postgresql import JSONB
from sqlalchemy.ext.hybrid import hybrid_property
from sqlalchemy.exc import SQLAlchemyError
from flask import current_app, g, has_app_context

from extensions import db, metrics
from models.base import BaseModel, AuditableMixin
from models.security.audit_log import AuditLog
from core.security.cs_audit import log_security_event


class Vulnerability(BaseModel, AuditableMixin):
    """
    Model representing a security vulnerability within the platform.

    This model tracks vulnerabilities from discovery through remediation,
    integrating with security scanning, threat intelligence, and incident
    management components.

    Attributes:
        id: Primary key
        title: Short title of the vulnerability
        description: Detailed description of the vulnerability
        cve_id: Common Vulnerabilities and Exposures identifier
        cvss_score: Common Vulnerability Scoring System score (0.0-10.0)
        cvss_vector: CVSS vector string
        severity: Calculated severity level based on CVSS score
        status: Current status of vulnerability
        affected_resources: List of affected resources
        exploit_available: Whether exploit code is publicly available
        exploited_in_wild: Whether vulnerability is being exploited
        vulnerability_type: Category of vulnerability
        asset_criticality: Criticality of the affected asset
        remediation_steps: Steps required to remediate vulnerability
        remediation_deadline: When remediation must be completed
        resolved_at: When vulnerability was resolved
        resolution_summary: Description of how the vulnerability was fixed
        verified_at: When resolution was verified
        verified_by_id: User who verified the resolution
        created_at: When record was created
        updated_at: When record was last updated
        discovered_at: When the vulnerability was discovered
        reported_by_id: User who reported the vulnerability
        assigned_to_id: User assigned to fix the vulnerability
        tags: List of tags for categorization
        external_references: External links and references
        risk_score: Calculated risk score considering multiple factors
        detection_source: How the vulnerability was detected
    """

    # Define security-critical fields for AuditableMixin
    SECURITY_CRITICAL_FIELDS = ['severity', 'status', 'remediation_deadline',
                             'exploited_in_wild', 'affected_resources']
    AUDIT_ACCESS = True

    __tablename__ = 'vulnerabilities'

    # Status constants
    STATUS_OPEN = 'open'
    STATUS_IN_PROGRESS = 'in_progress'
    STATUS_RESOLVED = 'resolved'
    STATUS_VERIFIED = 'verified'
    STATUS_CLOSED = 'closed'
    STATUS_DUPLICATE = 'duplicate'
    STATUS_FALSE_POSITIVE = 'false_positive'
    STATUS_RISK_ACCEPTED = 'risk_accepted'
    STATUS_WONT_FIX = 'wont_fix'

    VALID_STATUSES = [
        STATUS_OPEN, STATUS_IN_PROGRESS, STATUS_RESOLVED, STATUS_VERIFIED,
        STATUS_CLOSED, STATUS_DUPLICATE, STATUS_FALSE_POSITIVE,
        STATUS_RISK_ACCEPTED, STATUS_WONT_FIX
    ]

    # Severity constants
    SEVERITY_CRITICAL = 'critical'
    SEVERITY_HIGH = 'high'
    SEVERITY_MEDIUM = 'medium'
    SEVERITY_LOW = 'low'
    SEVERITY_INFO = 'info'

    VALID_SEVERITIES = [
        SEVERITY_CRITICAL, SEVERITY_HIGH, SEVERITY_MEDIUM,
        SEVERITY_LOW, SEVERITY_INFO
    ]

    # Vulnerability type constants
    TYPE_CODE = 'code'
    TYPE_CONFIG = 'configuration'
    TYPE_INFRASTRUCTURE = 'infrastructure'
    TYPE_NETWORK = 'network'
    TYPE_PLATFORM = 'platform'
    TYPE_SOFTWARE = 'software'
    TYPE_THIRD_PARTY = 'third_party'
    TYPE_WEB_APP = 'web_application'
    TYPE_OTHER = 'other'

    VALID_TYPES = [
        TYPE_CODE, TYPE_CONFIG, TYPE_INFRASTRUCTURE, TYPE_NETWORK,
        TYPE_PLATFORM, TYPE_SOFTWARE, TYPE_THIRD_PARTY, TYPE_WEB_APP,
        TYPE_OTHER
    ]

    # Detection source constants
    SOURCE_SCAN = 'security_scan'
    SOURCE_MANUAL = 'manual'
    SOURCE_PENETRATION_TEST = 'penetration_test'
    SOURCE_THREAT_INTEL = 'threat_intelligence'
    SOURCE_VENDOR = 'vendor_advisory'
    SOURCE_THIRD_PARTY = 'third_party'
    SOURCE_INCIDENT = 'security_incident'

    VALID_SOURCES = [
        SOURCE_SCAN, SOURCE_MANUAL, SOURCE_PENETRATION_TEST,
        SOURCE_THREAT_INTEL, SOURCE_VENDOR, SOURCE_THIRD_PARTY,
        SOURCE_INCIDENT
    ]

    # Asset criticality levels
    CRITICALITY_CRITICAL = 'critical'
    CRITICALITY_HIGH = 'high'
    CRITICALITY_MEDIUM = 'medium'
    CRITICALITY_LOW = 'low'

    VALID_CRITICALITIES = [
        CRITICALITY_CRITICAL, CRITICALITY_HIGH,
        CRITICALITY_MEDIUM, CRITICALITY_LOW
    ]

    # Primary columns
    id = db.Column(db.Integer, primary_key=True)
    title = db.Column(db.String(255), nullable=False)
    description = db.Column(db.Text, nullable=False)
    cve_id = db.Column(db.String(20), nullable=True, index=True)
    cvss_score = db.Column(db.Float, nullable=True)
    cvss_vector = db.Column(db.String(100), nullable=True)
    severity = db.Column(db.String(10), nullable=False, index=True)
    status = db.Column(db.String(20), nullable=False, default=STATUS_OPEN, index=True)

    # Affected resources stored as JSONB for flexibility
    affected_resources = db.Column(JSONB, nullable=True)

    # Exploitation data
    exploit_available = db.Column(db.Boolean, default=False)
    exploited_in_wild = db.Column(db.Boolean, default=False)
    vulnerability_type = db.Column(db.String(20), nullable=True)
    asset_criticality = db.Column(db.String(10), nullable=True)

    # Remediation information
    remediation_steps = db.Column(db.Text, nullable=True)
    remediation_deadline = db.Column(db.DateTime(timezone=True), nullable=True, index=True)

    # Timestamps
    discovered_at = db.Column(db.DateTime(timezone=True), nullable=False,
                           default=lambda: datetime.now(timezone.utc))
    resolved_at = db.Column(db.DateTime(timezone=True), nullable=True)
    verified_at = db.Column(db.DateTime(timezone=True), nullable=True)
    created_at = db.Column(db.DateTime(timezone=True), nullable=False,
                        default=lambda: datetime.now(timezone.utc))
    updated_at = db.Column(db.DateTime(timezone=True), nullable=False,
                        default=lambda: datetime.now(timezone.utc),
                        onupdate=lambda: datetime.now(timezone.utc))

    # Related people
    reported_by_id = db.Column(db.Integer, db.ForeignKey('users.id', ondelete='SET NULL'), nullable=True)
    assigned_to_id = db.Column(db.Integer, db.ForeignKey('users.id', ondelete='SET NULL'), nullable=True)
    verified_by_id = db.Column(db.Integer, db.ForeignKey('users.id', ondelete='SET NULL'), nullable=True)

    # Additional data
    resolution_summary = db.Column(db.Text, nullable=True)
    risk_score = db.Column(db.Float, nullable=True)
    detection_source = db.Column(db.String(20), nullable=True)
    tags = db.Column(JSONB, nullable=True)  # Using JSONB for cross-db compatibility
    external_references = db.Column(JSONB, nullable=True)

    # Relationships
    reported_by = db.relationship('User', foreign_keys=[reported_by_id], lazy='joined')
    assigned_to = db.relationship('User', foreign_keys=[assigned_to_id], lazy='joined')
    verified_by = db.relationship('User', foreign_keys=[verified_by_id], lazy='joined')

    # Security scan association (optional)
    scan_id = db.Column(db.Integer, db.ForeignKey('security_scans.id', ondelete='SET NULL'), nullable=True)
    scan = db.relationship('SecurityScan', backref=db.backref('vulnerabilities', lazy='dynamic'))

    # If this is a duplicate, store the ID of the original vulnerability
    duplicate_of_id = db.Column(db.Integer, db.ForeignKey('vulnerabilities.id', ondelete='SET NULL'), nullable=True)
    duplicate_of = db.relationship('Vulnerability', remote_side=[id], backref='duplicates')

    def __init__(self, **kwargs):
        """Initialize a new vulnerability record."""
        # Setup defaults for timestamps
        kwargs.setdefault('created_at', datetime.now(timezone.utc))
        kwargs.setdefault('updated_at', datetime.now(timezone.utc))

        # Default status is open
        kwargs.setdefault('status', self.STATUS_OPEN)

        # Calculate severity from CVSS if provided
        if 'cvss_score' in kwargs and kwargs['cvss_score'] is not None and 'severity' not in kwargs:
            kwargs['severity'] = self.calculate_severity_from_cvss(kwargs['cvss_score'])

        # Ensure severity is valid
        severity = kwargs.get('severity')
        if severity and severity not in self.VALID_SEVERITIES:
            raise ValueError(f"Invalid severity: {severity}")

        # Ensure status is valid
        status = kwargs.get('status')
        if status and status not in self.VALID_STATUSES:
            raise ValueError(f"Invalid status: {status}")

        # Ensure vulnerability type is valid (if provided)
        vuln_type = kwargs.get('vulnerability_type')
        if vuln_type and vuln_type not in self.VALID_TYPES:
            raise ValueError(f"Invalid vulnerability type: {vuln_type}")

        # Validate CVSS vector if provided
        cvss_vector = kwargs.get('cvss_vector')
        if cvss_vector and not self._validate_cvss_vector(cvss_vector):
            raise ValueError(f"Invalid CVSS vector: {cvss_vector}")

        # Set discovered_at if not provided
        kwargs.setdefault('discovered_at', datetime.now(timezone.utc))

        # Make sure tags is a list or convert to list
        tags = kwargs.get('tags')
        if tags is not None and not isinstance(tags, list):
            if isinstance(tags, str):
                kwargs['tags'] = [t.strip() for t in tags.split(',') if t.strip()]
            else:
                kwargs['tags'] = []

        # Ensure affected_resources is a list
        affected = kwargs.get('affected_resources')
        if affected is not None and not isinstance(affected, list):
            kwargs['affected_resources'] = [affected]

        # Initialize the instance
        super().__init__(**kwargs)

        # Calculate risk score
        self._update_risk_score()

    def update(self, **kwargs) -> None:
        """
        Update vulnerability record attributes.

        Args:
            **kwargs: Attributes to update
        """
        # Validate severity if provided
        if 'severity' in kwargs and kwargs['severity'] not in self.VALID_SEVERITIES:
            raise ValueError(f"Invalid severity: {kwargs['severity']}")

        # Validate status if provided
        if 'status' in kwargs and kwargs['status'] not in self.VALID_STATUSES:
            raise ValueError(f"Invalid status: {kwargs['status']}")

        # Validate type if provided
        if 'vulnerability_type' in kwargs and kwargs['vulnerability_type'] not in self.VALID_TYPES:
            raise ValueError(f"Invalid vulnerability type: {kwargs['vulnerability_type']}")

        # Validate CVSS vector if provided
        if 'cvss_vector' in kwargs and not self._validate_cvss_vector(kwargs['cvss_vector']):
            raise ValueError(f"Invalid CVSS vector: {kwargs['cvss_vector']}")

        # Handle tags if provided
        if 'tags' in kwargs and not isinstance(kwargs['tags'], list):
            if isinstance(kwargs['tags'], str):
                kwargs['tags'] = [t.strip() for t in kwargs['tags'].split(',') if t.strip()]
            else:
                kwargs['tags'] = []

        # Calculate severity from CVSS if CVSS is changing but severity isn't explicitly set
        if 'cvss_score' in kwargs and kwargs['cvss_score'] is not None and 'severity' not in kwargs:
            kwargs['severity'] = self.calculate_severity_from_cvss(kwargs['cvss_score'])

        # If status changes to resolved, set resolved_at if not provided
        if kwargs.get('status') == self.STATUS_RESOLVED and 'resolved_at' not in kwargs:
            kwargs['resolved_at'] = datetime.now(timezone.utc)

        # If status changes to verified, set verified_at if not provided
        if kwargs.get('status') == self.STATUS_VERIFIED and 'verified_at' not in kwargs:
            kwargs['verified_at'] = datetime.now(timezone.utc)

        # Store current status for event logging
        self._previous_status = self.status

        # Update attributes
        for key, value in kwargs.items():
            if hasattr(self, key):
                setattr(self, key, value)

        # Always update the updated_at timestamp
        self.updated_at = datetime.now(timezone.utc)

        # Recalculate risk score
        self._update_risk_score()

    def save(self) -> bool:
        """
        Save the vulnerability record to database.

        Returns:
            bool: Success status
        """
        try:
            db.session.add(self)
            db.session.commit()

            # Update metrics after successful save
            self._update_metrics()

            # Log security event for significant status changes
            if hasattr(self, '_previous_status') and self._previous_status != self.status:
                self._log_status_change(self._previous_status, self.status)

            return True
        except SQLAlchemyError as e:
            db.session.rollback()
            if has_app_context() and current_app.logger:
                current_app.logger.error(f"Error saving vulnerability record: {e}")
            return False

    def assign_to(self, user_id: int, assigned_by_id: Optional[int] = None) -> None:
        """
        Assign vulnerability to a user.

        Args:
            user_id: User ID to assign to
            assigned_by_id: User ID making the assignment
        """
        # Store previous state for change tracking
        self._previous_status = self.status

        # Change status to in_progress if it's currently open
        if self.status == self.STATUS_OPEN:
            self.status = self.STATUS_IN_PROGRESS

        # Update the assignee
        self.assigned_to_id = user_id
        self.updated_at = datetime.now(timezone.utc)

        # Log the assignment
        log_security_event(
            event_type=AuditLog.EVENT_SECURITY_VULNERABILITY,
            description=f"Vulnerability #{self.id} assigned to user ID {user_id}",
            severity=self.severity,
            user_id=assigned_by_id,
            object_type='Vulnerability',
            object_id=self.id,
            details={
                "title": self.title,
                "cve_id": self.cve_id,
                "previous_status": self._previous_status,
                "new_status": self.status,
                "assigned_to_id": user_id,
                "assigned_by_id": assigned_by_id
            }
        )

    def resolve(self, resolution_summary: str, user_id: Optional[int] = None) -> None:
        """
        Mark vulnerability as resolved.

        Args:
            resolution_summary: Description of how vulnerability was resolved
            user_id: User ID resolving the vulnerability
        """
        # Store previous state for change tracking
        self._previous_status = self.status

        # Update status and resolution info
        self.status = self.STATUS_RESOLVED
        self.resolution_summary = resolution_summary
        self.resolved_at = datetime.now(timezone.utc)
        self.updated_at = datetime.now(timezone.utc)

        # Log the resolution
        log_security_event(
            event_type=AuditLog.EVENT_SECURITY_VULNERABILITY,
            description=f"Vulnerability #{self.id} resolved",
            severity=self.severity,
            user_id=user_id,
            object_type='Vulnerability',
            object_id=self.id,
            details={
                "title": self.title,
                "cve_id": self.cve_id,
                "previous_status": self._previous_status,
                "new_status": self.STATUS_RESOLVED,
                "resolved_by_id": user_id,
                "resolution_summary": resolution_summary[:100] + '...' if len(resolution_summary) > 100 else resolution_summary
            }
        )

    def verify(self, user_id: Optional[int] = None) -> None:
        """
        Verify that the vulnerability has been properly resolved.

        Args:
            user_id: User ID performing verification
        """
        # Can only verify resolved vulnerabilities
        if self.status != self.STATUS_RESOLVED:
            raise ValueError("Only resolved vulnerabilities can be verified")

        # Store previous state for change tracking
        self._previous_status = self.status

        # Update status and verification details
        self.status = self.STATUS_VERIFIED
        self.verified_at = datetime.now(timezone.utc)
        self.verified_by_id = user_id
        self.updated_at = datetime.now(timezone.utc)

        # Log the verification
        log_security_event(
            event_type=AuditLog.EVENT_SECURITY_VULNERABILITY,
            description=f"Vulnerability #{self.id} verified as resolved",
            severity=self.severity,
            user_id=user_id,
            object_type='Vulnerability',
            object_id=self.id,
            details={
                "title": self.title,
                "cve_id": self.cve_id,
                "previous_status": self._previous_status,
                "new_status": self.STATUS_VERIFIED,
                "verified_by_id": user_id
            }
        )

    def close(self, reason: Optional[str] = None, user_id: Optional[int] = None) -> None:
        """
        Close the vulnerability record.

        Args:
            reason: Reason for closing
            user_id: User ID closing the record
        """
        # Store previous state for change tracking
        self._previous_status = self.status

        # Update status
        self.status = self.STATUS_CLOSED
        self.updated_at = datetime.now(timezone.utc)

        # Log the closure
        log_security_event(
            event_type=AuditLog.EVENT_SECURITY_VULNERABILITY,
            description=f"Vulnerability #{self.id} closed",
            severity=self.severity,
            user_id=user_id,
            object_type='Vulnerability',
            object_id=self.id,
            details={
                "title": self.title,
                "cve_id": self.cve_id,
                "previous_status": self._previous_status,
                "new_status": self.STATUS_CLOSED,
                "reason": reason,
                "closed_by_id": user_id
            }
        )

    def mark_as_duplicate(self, original_id: int, user_id: Optional[int] = None) -> None:
        """
        Mark vulnerability as a duplicate of another vulnerability.

        Args:
            original_id: ID of the original vulnerability
            user_id: User ID marking as duplicate
        """
        # Store previous state for change tracking
        self._previous_status = self.status

        # Update status and duplicate reference
        self.status = self.STATUS_DUPLICATE
        self.duplicate_of_id = original_id
        self.updated_at = datetime.now(timezone.utc)

        # Log the duplicate marking
        log_security_event(
            event_type=AuditLog.EVENT_SECURITY_VULNERABILITY,
            description=f"Vulnerability #{self.id} marked as duplicate of #{original_id}",
            severity=self.severity,
            user_id=user_id,
            object_type='Vulnerability',
            object_id=self.id,
            details={
                "title": self.title,
                "cve_id": self.cve_id,
                "previous_status": self._previous_status,
                "new_status": self.STATUS_DUPLICATE,
                "duplicate_of_id": original_id,
                "marked_by_id": user_id
            }
        )

    def mark_as_false_positive(self, reason: str, user_id: Optional[int] = None) -> None:
        """
        Mark vulnerability as a false positive.

        Args:
            reason: Explanation of why this is a false positive
            user_id: User ID marking as false positive
        """
        # Store previous state for change tracking
        self._previous_status = self.status

        # Update status and explanation
        self.status = self.STATUS_FALSE_POSITIVE
        self.resolution_summary = reason
        self.updated_at = datetime.now(timezone.utc)

        # Log the false positive marking
        log_security_event(
            event_type=AuditLog.EVENT_SECURITY_VULNERABILITY,
            description=f"Vulnerability #{self.id} marked as false positive",
            severity=self.severity,
            user_id=user_id,
            object_type='Vulnerability',
            object_id=self.id,
            details={
                "title": self.title,
                "cve_id": self.cve_id,
                "previous_status": self._previous_status,
                "new_status": self.STATUS_FALSE_POSITIVE,
                "reason": reason[:100] + '...' if len(reason) > 100 else reason,
                "marked_by_id": user_id
            }
        )

    def accept_risk(self, reason: str, user_id: Optional[int] = None) -> None:
        """
        Accept the risk posed by this vulnerability.

        Args:
            reason: Explanation of why risk is being accepted
            user_id: User ID accepting the risk
        """
        # Store previous state for change tracking
        self._previous_status = self.status

        # Update status
        self.status = self.STATUS_RISK_ACCEPTED
        self.resolution_summary = reason
        self.updated_at = datetime.now(timezone.utc)

        # Log the risk acceptance
        log_security_event(
            event_type=AuditLog.EVENT_SECURITY_VULNERABILITY,
            description=f"Risk accepted for vulnerability #{self.id}",
            severity=self.severity,
            user_id=user_id,
            object_type='Vulnerability',
            object_id=self.id,
            details={
                "title": self.title,
                "cve_id": self.cve_id,
                "previous_status": self._previous_status,
                "new_status": self.STATUS_RISK_ACCEPTED,
                "reason": reason[:100] + '...' if len(reason) > 100 else reason,
                "accepted_by_id": user_id
            }
        )

    def reopen(self, reason: str, user_id: Optional[int] = None) -> None:
        """
        Reopen a previously resolved/closed vulnerability.

        Args:
            reason: Reason for reopening
            user_id: User ID reopening the vulnerability
        """
        # Only reopen if not already open or in progress
        if self.status in [self.STATUS_OPEN, self.STATUS_IN_PROGRESS]:
            return

        # Store previous state for change tracking
        self._previous_status = self.status

        # Update status
        self.status = self.STATUS_OPEN
        self.updated_at = datetime.now(timezone.utc)

        # If there's an existing resolution summary, append the reopening reason
        if self.resolution_summary:
            self.resolution_summary += f"\n\n[REOPENED {datetime.now(timezone.utc).strftime('%Y-%m-%d')}] {reason}"

        # Log the reopening
        log_security_event(
            event_type=AuditLog.EVENT_SECURITY_VULNERABILITY,
            description=f"Vulnerability #{self.id} reopened",
            severity=self.severity,
            user_id=user_id,
            object_type='Vulnerability',
            object_id=self.id,
            details={
                "title": self.title,
                "cve_id": self.cve_id,
                "previous_status": self._previous_status,
                "new_status": self.STATUS_OPEN,
                "reason": reason[:100] + '...' if len(reason) > 100 else reason,
                "reopened_by_id": user_id
            }
        )

    def add_affected_resource(self, resource: Dict[str, Any]) -> None:
        """
        Add an affected resource to the vulnerability.

        Args:
            resource: Resource information (must have at least 'type' and 'id' fields)
        """
        # Validate resource format
        if not isinstance(resource, dict) or 'type' not in resource or 'id' not in resource:
            raise ValueError("Resource must be a dictionary with 'type' and 'id' fields")

        # Initialize affected_resources if None
        if self.affected_resources is None:
            self.affected_resources = []

        # Check if resource is already in list
        for existing in self.affected_resources:
            if (existing.get('type') == resource['type'] and
                existing.get('id') == resource['id']):
                return

        # Add the resource
        self.affected_resources.append(resource)
        self.updated_at = datetime.now(timezone.utc)

    def remove_affected_resource(self, resource_type: str, resource_id: str) -> bool:
        """
        Remove an affected resource from the vulnerability.

        Args:
            resource_type: Type of resource
            resource_id: ID of resource

        Returns:
            bool: True if resource was removed, False otherwise
        """
        # If no affected resources, return False
        if not self.affected_resources:
            return False

        # Find the resource in the list
        initial_length = len(self.affected_resources)
        self.affected_resources = [
            res for res in self.affected_resources
            if not (res.get('type') == resource_type and str(res.get('id')) == str(resource_id))
        ]

        # If the list changed, update timestamp and return True
        if len(self.affected_resources) < initial_length:
            self.updated_at = datetime.now(timezone.utc)
            return True

        return False

    def add_tag(self, tag: str) -> None:
        """
        Add a tag to the vulnerability.

        Args:
            tag: Tag to add
        """
        # Normalize tag
        tag = tag.strip().lower()
        if not tag:
            return

        # Initialize tags if None
        if self.tags is None:
            self.tags = []

        # Check if tag already exists
        if tag in self.tags:
            return

        # Add the tag
        self.tags.append(tag)
        self.updated_at = datetime.now(timezone.utc)

    def remove_tag(self, tag: str) -> bool:
        """
        Remove a tag from the vulnerability.

        Args:
            tag: Tag to remove

        Returns:
            bool: True if tag was removed, False otherwise
        """
        # If no tags, return False
        if not self.tags:
            return False

        # Normalize tag
        tag = tag.strip().lower()

        # Check if tag exists and remove it
        if tag in self.tags:
            self.tags.remove(tag)
            self.updated_at = datetime.now(timezone.utc)
            return True

        return False

    def add_external_reference(self, ref_type: str, reference: str, description: Optional[str] = None) -> None:
        """
        Add an external reference to the vulnerability.

        Args:
            ref_type: Type of reference (e.g., 'url', 'bug_tracker', 'advisory')
            reference: The reference value (e.g., URL, ID)
            description: Optional description of the reference
        """
        # Initialize external_references if None
        if self.external_references is None:
            self.external_references = []

        # Create the reference object
        ref_object = {
            'type': ref_type,
            'reference': reference,
            'added_at': datetime.now(timezone.utc).isoformat()
        }

        if description:
            ref_object['description'] = description

        # Check if reference already exists
        for existing in self.external_references:
            if existing.get('type') == ref_type and existing.get('reference') == reference:
                return

        # Add the reference
        self.external_references.append(ref_object)
        self.updated_at = datetime.now(timezone.utc)

    def to_dict(self) -> Dict[str, Any]:
        """
        Convert vulnerability record to dictionary.

        Returns:
            Dict[str, Any]: Dictionary representation
        """
        result = {
            'id': self.id,
            'title': self.title,
            'description': self.description,
            'cve_id': self.cve_id,
            'cvss_score': self.cvss_score,
            'cvss_vector': self.cvss_vector,
            'severity': self.severity,
            'status': self.status,
            'affected_resources': self.affected_resources,
            'exploit_available': self.exploit_available,
            'exploited_in_wild': self.exploited_in_wild,
            'vulnerability_type': self.vulnerability_type,
            'asset_criticality': self.asset_criticality,
            'remediation_steps': self.remediation_steps,
            'remediation_deadline': self.remediation_deadline.isoformat() if self.remediation_deadline else None,
            'discovered_at': self.discovered_at.isoformat() if self.discovered_at else None,
            'resolved_at': self.resolved_at.isoformat() if self.resolved_at else None,
            'verified_at': self.verified_at.isoformat() if self.verified_at else None,
            'created_at': self.created_at.isoformat() if self.created_at else None,
            'updated_at': self.updated_at.isoformat() if self.updated_at else None,
            'reported_by_id': self.reported_by_id,
            'assigned_to_id': self.assigned_to_id,
            'verified_by_id': self.verified_by_id,
            'resolution_summary': self.resolution_summary,
            'risk_score': self.risk_score,
            'detection_source': self.detection_source,
            'tags': self.tags,
            'external_references': self.external_references,
            'scan_id': self.scan_id,
            'duplicate_of_id': self.duplicate_of_id,
            'sla_status': self.sla_status,
            'age_days': self.age_days,
            'is_overdue': self.is_overdue
        }

        # Add user information if available
        if self.reported_by:
            result['reported_by'] = {
                'id': self.reported_by.id,
                'username': getattr(self.reported_by, 'username', f'User #{self.reported_by_id}')
            }

        if self.assigned_to:
            result['assigned_to'] = {
                'id': self.assigned_to.id,
                'username': getattr(self.assigned_to, 'username', f'User #{self.assigned_to_id}')
            }

        if self.verified_by:
            result['verified_by'] = {
                'id': self.verified_by.id,
                'username': getattr(self.verified_by, 'username', f'User #{self.verified_by_id}')
            }

        return result

    # Hybrid properties

    @hybrid_property
    def is_active(self) -> bool:
        """Check if vulnerability is still active (not resolved/closed/etc.)."""
        return self.status in [self.STATUS_OPEN, self.STATUS_IN_PROGRESS]

    @hybrid_property
    def is_resolved(self) -> bool:
        """Check if vulnerability is resolved or closed."""
        return self.status in [self.STATUS_RESOLVED, self.STATUS_VERIFIED, self.STATUS_CLOSED]

    @hybrid_property
    def age_days(self) -> int:
        """Calculate age of vulnerability in days."""
        if not self.discovered_at:
            return 0

        delta = datetime.now(timezone.utc) - self.discovered_at
        return delta.days

    @hybrid_property
    def time_to_resolution_days(self) -> Optional[int]:
        """Calculate time to resolution in days if resolved."""
        if not self.resolved_at or not self.discovered_at:
            return None

        delta = self.resolved_at - self.discovered_at
        return delta.days

    @hybrid_property
    def is_overdue(self) -> bool:
        """Check if vulnerability remediation is overdue."""
        return (self.is_active and
                self.remediation_deadline is not None and
                datetime.now(timezone.utc) > self.remediation_deadline)

    @hybrid_property
    def sla_status(self) -> str:
        """
        Get SLA status for this vulnerability.

        Returns:
            str: 'overdue', 'at_risk', or 'within_sla'
        """
        if not self.is_active or not self.remediation_deadline:
            return 'within_sla'

        now = datetime.now(timezone.utc)

        if now > self.remediation_deadline:
            return 'overdue'

        # At risk if deadline is within the next 7 days
        if now + timedelta(days=7) > self.remediation_deadline:
            return 'at_risk'

        return 'within_sla'

    @hybrid_property
    def days_until_deadline(self) -> Optional[int]:
        """Calculate days until remediation deadline."""
        if not self.remediation_deadline:
            return None

        delta = self.remediation_deadline - datetime.now(timezone.utc)
        return max(0, delta.days)

    # Class methods for queries

    @classmethod
    def find_by_id(cls, vuln_id: int) -> Optional['Vulnerability']:
        """
        Find a vulnerability by ID.

        Args:
            vuln_id: Vulnerability ID

        Returns:
            Vulnerability object or None
        """
        try:
            return cls.query.get(vuln_id)
        except SQLAlchemyError as e:
            if has_app_context() and current_app.logger:
                current_app.logger.error(f"Error finding vulnerability by ID: {e}")
            return None

    @classmethod
    def find_by_cve(cls, cve_id: str) -> Optional['Vulnerability']:
        """
        Find a vulnerability by CVE ID.

        Args:
            cve_id: CVE ID

        Returns:
            Vulnerability object or None
        """
        try:
            # Normalize the CVE ID format
            if cve_id and not cve_id.upper().startswith('CVE-'):
                cve_id = f"CVE-{cve_id}"

            return cls.query.filter(cls.cve_id == cve_id.upper()).first()
        except SQLAlchemyError as e:
            if has_app_context() and current_app.logger:
                current_app.logger.error(f"Error finding vulnerability by CVE: {e}")
            return None

    @classmethod
    def create_from_finding(cls, **kwargs) -> 'Vulnerability':
        """
        Create vulnerability record from security scan finding.

        Args:
            **kwargs: Finding attributes

        Returns:
            Vulnerability: Created vulnerability record
        """
        # Translate between finding fields and vulnerability fields
        data = {}

        # Map directly transferable fields
        for field in ['title', 'description', 'severity', 'cvss_score', 'cvss_vector']:
            if field in kwargs:
                data[field] = kwargs[field]

        # Handle specific fields with different names
        if 'remediation' in kwargs:
            data['remediation_steps'] = kwargs['remediation']

        if 'type' in kwargs:
            data['vulnerability_type'] = kwargs['type']

        # Handle affected resources
        if 'affected_resource' in kwargs:
            resource_info = kwargs.get('resource_details', {})
            resource = {
                'type': kwargs.get('resource_type', 'unknown'),
                'id': kwargs['affected_resource'],
            }

            # Add any additional resource details
            if resource_info:
                resource.update(resource_info)

            data['affected_resources'] = [resource]

        # Set scan ID if provided
        if 'scan_id' in kwargs:
            data['scan_id'] = kwargs['scan_id']

        # Set default detection source
        data['detection_source'] = cls.SOURCE_SCAN

        # Set calculated fields
        data['status'] = cls.STATUS_OPEN

        # Calculate remediation deadline based on severity
        if 'severity' in data:
            days = cls._calculate_remediation_timeframe(
                data['severity'],
                kwargs.get('exploit_available', False),
                kwargs.get('exploited_in_wild', False)
            )

            data['remediation_deadline'] = datetime.now(timezone.utc) + timedelta(days=days)

        # Create and return the vulnerability record
        vulnerability = cls(**data)
        vulnerability.save()
        return vulnerability

    @classmethod
    def find_similar(cls, finding: Dict[str, Any]) -> Optional['Vulnerability']:
        """
        Find a similar existing vulnerability based on finding data.

        Args:
            finding: Finding data with attributes like title, CVE, etc.

        Returns:
            Vulnerability object if similar one found, None otherwise
        """
        try:
            # Check for CVE match first
            if 'cve_id' in finding and finding['cve_id']:
                cve_vuln = cls.find_by_cve(finding['cve_id'])
                if cve_vuln:
                    return cve_vuln

            # Try to find by title and affected resource
            if 'title' in finding and finding['title'] and 'affected_resource' in finding:
                query = cls.query.filter(cls.title == finding['title'])

                # Use database-specific JSON query if PostgreSQL
                if db.engine.dialect.name == 'postgresql' and 'affected_resource' in finding:
                    resource_type = finding.get('resource_type', 'unknown')
                    resource_id = finding['affected_resource']

                    query = query.filter(
                        cls.affected_resources.contains([{
                            'type': resource_type,
                            'id': resource_id
                        }])
                    )

                vuln = query.first()
                if vuln:
                    return vuln

            # If all else fails, return None (no similar vulnerability found)
            return None

        except SQLAlchemyError as e:
            if has_app_context() and current_app.logger:
                current_app.logger.error(f"Error finding similar vulnerability: {e}")
            return None

    @classmethod
    def get_paginated(cls, page: int = 1, per_page: int = 20,
                     sort_by: str = 'updated_at', sort_direction: str = 'desc',
                     filters: Optional[Dict[str, Any]] = None) -> Tuple[List['Vulnerability'], int]:
        """
        Get paginated vulnerabilities with filtering and sorting.

        Args:
            page: Page number (starting from 1)
            per_page: Number of items per page
            sort_by: Field to sort by
            sort_direction: Sort direction ('asc' or 'desc')
            filters: Dictionary of filter criteria

        Returns:
            Tuple with (list of vulnerabilities, total count)
        """
        try:
            # Start with base query
            query = cls.query

            # Apply filters if provided
            if filters:
                if 'severity' in filters:
                    if isinstance(filters['severity'], list):
                        query = query.filter(cls.severity.in_(filters['severity']))
                    else:
                        query = query.filter(cls.severity == filters['severity'])

                if 'status' in filters:
                    if isinstance(filters['status'], list):
                        query = query.filter(cls.status.in_(filters['status']))
                    else:
                        query = query.filter(cls.status == filters['status'])

                if 'cve_id' in filters:
                    query = query.filter(cls.cve_id == filters['cve_id'])

                if 'vulnerability_type' in filters:
                    query = query.filter(cls.vulnerability_type == filters['vulnerability_type'])

                if 'reported_by_id' in filters:
                    query = query.filter(cls.reported_by_id == filters['reported_by_id'])

                if 'assigned_to_id' in filters:
                    query = query.filter(cls.assigned_to_id == filters['assigned_to_id'])

                if 'discovery_start_date' in filters:
                    query = query.filter(cls.discovered_at >= filters['discovery_start_date'])

                if 'discovery_end_date' in filters:
                    query = query.filter(cls.discovered_at <= filters['discovery_end_date'])

                if 'is_overdue' in filters and filters['is_overdue']:
                    query = query.filter(
                        cls.status.in_([cls.STATUS_OPEN, cls.STATUS_IN_PROGRESS]),
                        cls.remediation_deadline < datetime.now(timezone.utc)
                    )

                if 'search' in filters and filters['search']:
                    search_term = f"%{filters['search']}%"
                    query = query.filter(
                        or_(
                            cls.title.ilike(search_term),
                            cls.description.ilike(search_term),
                            cls.cve_id.ilike(search_term)
                        )
                    )

                if 'tags' in filters and filters['tags']:
                    if db.engine.dialect.name == 'postgresql':
                        # For PostgreSQL, use the JSONB contains operator
                        for tag in filters['tags']:
                            query = query.filter(cls.tags.contains([tag]))
                    else:
                        # For other databases, filter in Python (less efficient)
                        # This would need post-processing of results
                        pass

                if 'resource_type' in filters and 'resource_id' in filters:
                    if db.engine.dialect.name == 'postgresql':
                        # PostgreSQL JSON search
                        query = query.filter(
                            cls.affected_resources.contains([{
                                'type': filters['resource_type'],
                                'id': filters['resource_id']
                            }])
                        )
                    else:
                        # For other databases, filter in Python (less efficient)
                        # This would need post-processing of results
                        pass

            # Count before pagination for total
            total = query.count()

            # Apply sorting if the column exists
            if hasattr(cls, sort_by):
                column = getattr(cls, sort_by)
                if sort_direction.lower() == 'asc':
                    query = query.order_by(column.asc())
                else:
                    query = query.order_by(column.desc())
            else:
                # Default sorting by updated_at
                if sort_direction.lower() == 'asc':
                    query = query.order_by(cls.updated_at.asc())
                else:
                    query = query.order_by(cls.updated_at.desc())

            # Apply pagination
            vulnerabilities = query.offset((page - 1) * per_page).limit(per_page).all()

            return vulnerabilities, total
        except SQLAlchemyError as e:
            if has_app_context() and current_app.logger:
                current_app.logger.error(f"Error getting paginated vulnerabilities: {e}")
            return [], 0

    @classmethod
    def bulk_update(cls, vulnerability_ids: List[int],
                  update_data: Dict[str, Any]) -> int:
        """
        Update multiple vulnerabilities at once.

        Args:
            vulnerability_ids: List of vulnerability IDs to update
            update_data: Data to update for all vulnerabilities

        Returns:
            int: Number of vulnerabilities updated
        """
        try:
            # Prepare update values
            update_values = {}

            # Validate fields to update
            for key, value in update_data.items():
                # Skip invalid fields
                if not hasattr(cls, key):
                    continue

                # Validate enums
                if key == 'severity' and value not in cls.VALID_SEVERITIES:
                    continue
                if key == 'status' and value not in cls.VALID_STATUSES:
                    continue
                if key == 'vulnerability_type' and value not in cls.VALID_TYPES:
                    continue

                if key in ['resolved_at', 'verified_at', 'remediation_deadline']:
                    # Handle date fields
                    if isinstance(value, str):
                        try:
                            update_values[key] = datetime.fromisoformat(value)
                        except ValueError:
                            continue
                    elif isinstance(value, datetime):
                        update_values[key] = value
                    else:
                        continue
                elif key in ['tags', 'affected_resources', 'external_references']:
                    # Skip complex fields - these need to be updated individually
                    continue
                else:
                    # Standard field
                    update_values[key] = value

            # Always update the updated_at timestamp
            update_values['updated_at'] = datetime.now(timezone.utc)

            # Perform the update
            count = cls.query.filter(cls.id.in_(vulnerability_ids)).update(
                update_values, synchronize_session=False
            )

            db.session.commit()

            # Recalculate risk scores for updated vulnerabilities
            for vuln_id in vulnerability_ids:
                vuln = cls.find_by_id(vuln_id)
                if vuln:
                    vuln._update_risk_score()

            return count
        except SQLAlchemyError as e:
            db.session.rollback()
            if has_app_context() and current_app.logger:
                current_app.logger.error(f"Error performing bulk vulnerability update: {e}")
            return 0

    @classmethod
    def get_statistics(cls) -> Dict[str, Any]:
        """
        Get vulnerability statistics.

        Returns:
            Dict[str, Any]: Statistics about vulnerabilities
        """
        try:
            stats = {
                'total': 0,
                'by_severity': {},
                'by_status': {},
                'remediation_progress': {
                    'on_time': 0,
                    'at_risk': 0,
                    'overdue': 0
                },
                'top_affected_resources': []
            }

            # Get total count
            stats['total'] = cls.query.count()

            # Count by severity
            severity_counts = db.session.query(
                cls.severity, func.count(cls.id)
            ).group_by(cls.severity).all()

            for severity, count in severity_counts:
                stats['by_severity'][severity] = count

            # Count by status
            status_counts = db.session.query(
                cls.status, func.count(cls.id)
            ).group_by(cls.status).all()

            for status, count in status_counts:
                stats['by_status'][status] = count

            # Count remediation progress
            now = datetime.now(timezone.utc)

            # On time: active and before deadline
            stats['remediation_progress']['on_time'] = cls.query.filter(
                cls.status.in_([cls.STATUS_OPEN, cls.STATUS_IN_PROGRESS]),
                or_(
                    cls.remediation_deadline == None,
                    cls.remediation_deadline > now
                )
            ).count()

            # At risk: active and deadline within 7 days
            stats['remediation_progress']['at_risk'] = cls.query.filter(
                cls.status.in_([cls.STATUS_OPEN, cls.STATUS_IN_PROGRESS]),
                cls.remediation_deadline != None,
                cls.remediation_deadline <= now + timedelta(days=7),
                cls.remediation_deadline > now
            ).count()

            # Overdue: active and past deadline
            stats['remediation_progress']['overdue'] = cls.query.filter(
                cls.status.in_([cls.STATUS_OPEN, cls.STATUS_IN_PROGRESS]),
                cls.remediation_deadline != None,
                cls.remediation_deadline <= now
            ).count()

            # Implement top affected resources analysis based on database
            if db.engine.dialect.name == 'postgresql':
                # Using PostgreSQL-specific JSONB query
                resource_query = text("""
                    SELECT resource->>'type' as type, resource->>'id' as id, COUNT(*) as count
                    FROM vulnerabilities v,
                         jsonb_array_elements(v.affected_resources) as resource
                    GROUP BY resource->>'type', resource->>'id'
                    ORDER BY count DESC
                    LIMIT 10
                """)

                top_resources = db.session.execute(resource_query).fetchall()
                stats['top_affected_resources'] = [
                    {"type": r.type, "id": r.id, "count": r.count}
                    for r in top_resources
                ]

            return stats
        except SQLAlchemyError as e:
            if has_app_context() and current_app.logger:
                current_app.logger.error(f"Error getting vulnerability statistics: {e}")
            return {
                'error': 'Failed to retrieve statistics',
                'total': 0
            }

    @classmethod
    def calculate_severity_from_cvss(cls, cvss_score: float) -> str:
        """
        Calculate severity level from CVSS score.

        Args:
            cvss_score: CVSS score (0.0-10.0)

        Returns:
            Severity level string
        """
        if cvss_score is None:
            return cls.SEVERITY_MEDIUM

        if cvss_score >= 9.0:
            return cls.SEVERITY_CRITICAL
        elif cvss_score >= 7.0:
            return cls.SEVERITY_HIGH
        elif cvss_score >= 4.0:
            return cls.SEVERITY_MEDIUM
        elif cvss_score > 0.0:
            return cls.SEVERITY_LOW
        else:
            return cls.SEVERITY_INFO

    @classmethod
    def _calculate_remediation_timeframe(cls, severity: str,
                                      exploit_available: bool = False,
                                      exploited_in_wild: bool = False) -> int:
        """
        Calculate remediation timeframe in days based on severity and other factors.

        Args:
            severity: Vulnerability severity
            exploit_available: Whether public exploit is available
            exploited_in_wild: Whether vulnerability is being actively exploited

        Returns:
            int: Days allowed for remediation
        """
        # Base timeframe by severity
        if severity == cls.SEVERITY_CRITICAL:
            days = 7  # Critical: fix within 7 days
        elif severity == cls.SEVERITY_HIGH:
            days = 30  # High: fix within 30 days
        elif severity == cls.SEVERITY_MEDIUM:
            days = 90  # Medium: fix within 90 days
        else:
            days = 180  # Low/Info: fix within 180 days

        # Adjust for exploitation factors
        if exploited_in_wild:
            days = min(days, 7)  # Max 7 days for active exploitation
        elif exploit_available:
            days = days // 2  # Half the time if exploit is available

        return days

    # Private methods

    def _update_risk_score(self) -> None:
        """Update the calculated risk score."""
        # Base score from CVSS if available
        base_score = self.cvss_score if self.cvss_score is not None else 5.0

        # Start with normalized base score (0-10)
        risk_score = base_score

        # Adjust for active exploitation (up to +3)
        if self.exploited_in_wild:
            risk_score += 3
        elif self.exploit_available:
            risk_score += 1.5

        # Adjust for asset criticality (up to +2)
        if self.asset_criticality == self.CRITICALITY_CRITICAL:
            risk_score += 2
        elif self.asset_criticality == self.CRITICALITY_HIGH:
            risk_score += 1.5
        elif self.asset_criticality == self.CRITICALITY_MEDIUM:
            risk_score += 0.5

        # Cap at 10
        self.risk_score = min(10.0, risk_score)

    def _update_metrics(self) -> None:
        """Update metrics after save."""
        if not metrics:
            return

        try:
            # Track by severity
            metrics.info('security.vulnerabilities.by_severity', 1, labels={
                'severity': self.severity
            })

            # Track by status
            metrics.info('security.vulnerabilities.by_status', 1, labels={
                'status': self.status
            })

            # Track by type
            if self.vulnerability_type:
                metrics.info('security.vulnerabilities.by_type', 1, labels={
                    'type': self.vulnerability_type
                })

            # Track SLA status for active vulnerabilities
            if self.is_active and self.remediation_deadline:
                metrics.info('security.vulnerabilities.by_sla', 1, labels={
                    'sla_status': self.sla_status
                })

        except Exception as e:
            if has_app_context() and current_app.logger:
                current_app.logger.warning(f"Failed to update metrics: {e}")

    def _log_status_change(self, old_status: str, new_status: str) -> None:
        """
        Log a vulnerability status change event.

        Args:
            old_status: Previous status
            new_status: New status
        """
        try:
            log_security_event(
                event_type=AuditLog.EVENT_SECURITY_VULNERABILITY,
                description=f"Vulnerability #{self.id} status changed: {old_status}  {new_status}",
                severity=self.severity,
                object_type='Vulnerability',
                object_id=self.id,
                details={
                    "title": self.title,
                    "cve_id": self.cve_id,
                    "previous_status": old_status,
                    "new_status": new_status
                }
            )
        except Exception as e:
            if has_app_context() and current_app.logger:
                current_app.logger.error(f"Failed to log status change: {e}")

    @staticmethod
    def _validate_cvss_vector(vector: str) -> bool:
        """
        Validate a CVSS vector string.

        Args:
            vector: CVSS vector string

        Returns:
            bool: True if valid, False otherwise
        """
        if not vector:
            return False

        # Basic pattern for CVSS v3 vectors
        pattern = r'^CVSS:3\.[01]/AV:[NALP]/AC:[LH]/PR:[NLH]/UI:[NR]/S:[UC]/C:[NLH]/I:[NLH]/A:[NLH]'

        # Check if basic pattern matches
        if not re.match(pattern, vector):
            # Also allow standalone metrics for older CVSS formats
            if re.match(r'^AV:[NALP]/AC:[LH]/', vector):
                return True
            return False

        return True
