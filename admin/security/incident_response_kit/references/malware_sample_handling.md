# Malware Sample Handling Guidelines

## Contents

- [Overview](#overview)
- [Safety Precautions](#safety-precautions)
- [Sample Collection Procedures](#sample-collection-procedures)
- [Secure Storage](#secure-storage)
- [Handling and Analysis Workflow](#handling-and-analysis-workflow)
- [Chain of Custody](#chain-of-custody)
- [Transport and Sharing Protocols](#transport-and-sharing-protocols)
- [Quarantine Procedures](#quarantine-procedures)
- [Implementation Reference](#implementation-reference)
- [Available Functions](#available-functions)
- [Best Practices & Security](#best-practices--security)
- [Related Documentation](#related-documentation)

## Overview

This guide provides standardized procedures for securely handling malware samples during security incident response. Proper malware sample handling is critical to prevent accidental execution, maintain forensic integrity, and ensure the safety of incident responders and systems. These guidelines integrate with the Cloud Infrastructure Platform's malware containment capabilities to facilitate secure analysis while maintaining proper evidence handling procedures.

## Safety Precautions

### System Protection

1. **Isolation Requirements**
   - Handle suspicious files only on isolated systems
   - Use dedicated analysis VMs with no shared folders
   - Disable autorun features on all systems
   - Ensure analysis systems have no network connectivity to production
   - Apply principle of least privilege when executing samples

2. **Analysis Environment Controls**
   - Use non-persistent VMs with snapshot capability
   - Configure host-only networking for controlled environments
   - Implement network traffic monitoring and filtering
   - Install minimal required software to reduce attack surface
   - Remove sensitive data from analysis environments

3. **Endpoint Protection**
   - Disable automatic scanning of quarantine directories
   - Configure AV exclusions for analysis environments
   - Enable enhanced logging for security tools
   - Apply application whitelisting when possible
   - Implement file-based access controls

### Personnel Safety

1. **Training Requirements**
   - Complete malware analysis training prior to handling samples
   - Understand malware transmission vectors and prevention
   - Follow proper sample isolation protocols
   - Know emergency response procedures
   - Maintain current knowledge of malware trends

2. **Access Restrictions**
   - Limit malware sample access to authorized personnel
   - Implement role-based access controls for quarantine storage
   - Require MFA for accessing sample repositories
   - Maintain access logs for all sample handling
   - Review access permissions quarterly

3. **Standard Operating Procedures**
   - Never execute suspicious files on production systems
   - Always verify file hashes before and after transfers
   - Use dedicated hardware for high-risk samples
   - Report safety incidents immediately
   - Document all handling activities

## Sample Collection Procedures

### Collection Methods

1. **From Live Systems**
   - Boot system from trusted media when possible
   - Use write blockers for disk imaging
   - Collect RAM dumps before file extraction
   - Document system state before collection
   - Capture volatile data using forensic tools

2. **From Storage Media**
   - Use write blockers for all media
   - Create forensic images rather than direct copying
   - Verify hash values of original and copy
   - Document media condition and identifiers
   - Store original media securely after imaging

3. **From Detection Systems**
   - Extract samples from quarantine repositories
   - Preserve alert context and metadata
   - Document detection signatures triggered
   - Maintain original timestamps
   - Record detection system information

### Documentation Requirements

1. **Sample Metadata**
   - Source location and system information
   - Discovery timestamp and timezone
   - Associated user accounts
   - Detected behaviors
   - Alert details and context
   - Assigned malware ID following naming convention

2. **System Context**
   - Operating system version
   - Installed applications
   - System configuration
   - Network connectivity
   - Observed symptoms

3. **Collection Documentation**
   - Collector's name and contact information
   - Collection method used
   - Tools and commands executed
   - Chain of custody initiation
   - Integrity verification results

### Initial Containment

1. **Local System Isolation**
   - Disconnect system from network
   - Disable wireless interfaces
   - Document running processes before isolation
   - Capture memory before powering down
   - Prevent further execution of suspicious files

2. **Initial Triage**
   - Determine high-level risk assessment
   - Check file against known malware signatures
   - Document preliminary indicators
   - Assess potential for lateral movement
   - Evaluate business impact

3. **Secure Packaging**
   - Use encrypted containers for sample storage
   - Apply appropriate warning labels
   - Include handling instructions
   - Implement proper access controls
   - Create backup copy with same controls

## Secure Storage

### Storage Infrastructure

1. **Physical Storage Requirements**
   - Use dedicated, secured storage media
   - Implement proper environmental controls
   - Apply physical access restrictions
   - Maintain separate storage for high-risk samples
   - Implement backup procedures

2. **Digital Storage Requirements**
   - Encrypt all sample repositories
   - Implement access logging
   - Use dedicated storage systems
   - Apply retention policies
   - Configure automated integrity checking

3. **Quarantine Architecture**
   - Implement segregated storage by risk level
   - Apply principle of least privilege to access
   - Configure monitoring for access attempts
   - Establish secure deletion procedures
   - Enforce storage access approval workflows

### Storage Security Controls

1. **Access Control Mechanisms**
   - Implement multi-factor authentication
   - Apply role-based access controls
   - Log all access attempts
   - Conduct regular access reviews
   - Implement time-limited access

2. **Encryption Requirements**
   - Encrypt samples at rest with AES-256
   - Use secure key management procedures
   - Implement envelope encryption
   - Separate encryption keys from samples
   - Rotate encryption keys regularly

3. **Integrity Monitoring**
   - Calculate and store cryptographic hashes
   - Implement automated integrity checking
   - Verify hashes before and after transfers
   - Monitor for unauthorized modifications
   - Document all integrity verification results

## Handling and Analysis Workflow

### Pre-Analysis Preparation

1. **Environment Configuration**
   - Prepare isolated analysis environment
   - Take clean system snapshot
   - Configure monitoring tools
   - Verify isolation effectiveness
   - Test analysis tools on known samples

2. **Analysis Plan Development**
   - Determine analysis objectives
   - Select appropriate analysis techniques
   - Identify required tools and resources
   - Establish safety protocols
   - Define success criteria

3. **Risk Assessment**
   - Evaluate sample risk level
   - Determine appropriate handling procedures
   - Assess potential for anti-analysis techniques
   - Identify required safety controls
   - Document risk mitigation strategies

### Analysis Procedures

1. **Static Analysis**
   - Calculate and verify file hashes
   - Examine file properties and structure
   - Extract strings and metadata
   - Review embedded resources
   - Scan with multiple detection engines

2. **Dynamic Analysis**
   - Execute in isolated environment
   - Monitor system changes during execution
   - Capture network traffic
   - Document behavioral indicators
   - Record persistence mechanisms

3. **Memory Analysis**
   - Capture memory dumps during execution
   - Analyze memory for IOCs
   - Extract encryption keys or credentials
   - Identify obfuscated code
   - Document memory artifacts

### Post-Analysis Procedures

1. **Results Documentation**
   - Record all observed behaviors
   - Document indicators of compromise
   - Catalog capabilities and techniques
   - Identify potential attribution indicators
   - Create comprehensive analysis report

2. **Sample Classification**
   - Assign malware family if identified
   - Categorize by primary function
   - Document MITRE ATT&CK techniques
   - Assess severity and impact
   - Update sample metadata

3. **Containment Verification**
   - Verify sample remains properly contained
   - Update access controls based on risk assessment
   - Validate integrity of analyzed samples
   - Document containment status
   - Address any containment issues

## Chain of Custody

### Documentation Requirements

1. **Chain of Custody Form**
   - Sample identifiers and hashes
   - Collection details and timeline
   - Handler identification and contact information
   - Transfer records with timestamps
   - Storage location history

2. **Evidence Integrity**
   - Hash verification results
   - Access logs
   - Modification records
   - Integrity check history
   - Sample authentication mechanisms

3. **Transfer Documentation**
   - Transfer authorization
   - Sender and recipient information
   - Transfer method and security controls
   - Verification procedures used
   - Reason for transfer

### Custody Tracking

1. **Custody Logging**
   - Log all access to samples
   - Record purpose of access
   - Document duration of access
   - Track sample location at all times
   - Maintain continuous accountability

2. **Access Authorization**
   - Implement formal access request process
   - Require management approval for access
   - Limit access duration and scope
   - Document business justification
   - Verify authorization before granting access

3. **Custody Verification**
   - Conduct regular inventory audits
   - Perform periodic integrity checks
   - Verify chain of custody documentation
   - Reconcile access logs with authorizations
   - Address any custody discrepancies immediately

## Transport and Sharing Protocols

### Secure Transport Methods

1. **Digital Transport**
   - Use encrypted containers (VeraCrypt, BitLocker)
   - Transmit over encrypted channels
   - Use authenticated transfer protocols
   - Split encryption keys from samples
   - Verify integrity after transfer

2. **Physical Transport**
   - Use tamper-evident packaging
   - Implement dual-control procedures
   - Document chain of custody during transit
   - Use trusted courier services
   - Track packages at all times

3. **Transport Security Controls**
   - Encrypt media before transport
   - Apply proper handling labels
   - Include handling instructions
   - Use secure transport cases
   - Implement transport authorization procedures

### Sharing Guidelines

1. **Internal Sharing**
   - Verify business need to know
   - Document sharing authorization
   - Apply access controls
   - Track internal distribution
   - Limit timeframe for access

2. **External Sharing**
   - Obtain written authorization
   - Verify recipient's ability to handle safely
   - Use secure transfer mechanisms
   - Include handling requirements
   - Document external transfers

3. **Information Sharing Controls**
   - Apply TLP (Traffic Light Protocol) classification
   - Use secure sharing platforms
   - Implement data loss prevention
   - Audit shared resources
   - Maintain recipient acknowledgments

## Quarantine Procedures

### Using the MalwareContainment Module

1. **Quarantine File Procedure**
   - Use secure quarantine to isolate suspicious files
   - Preserve file metadata and context
   - Apply appropriate encryption
   - Document quarantine actions
   - Verify quarantine effectiveness

   ```python
   from admin.security.incident_response_kit import malware_containment

   # Initialize containment with incident ID
   containment = malware_containment.MalwareContainment(
       incident_id="IR-2023-042",
       quarantine_dir="/secure/quarantine",
       analyst="security_analyst"
   )

   # Quarantine suspicious file with encryption
   result = containment.quarantine_file(
       file_path="/path/to/suspicious_file.exe",
       metadata={
           "source_system": "WORKSTATION-HR001",
           "user_context": "jsmith",
           "alert_id": "AV-42391",
           "collection_time": "2023-07-15T13:45:22Z"
       },
       encrypt=True
   )

   if result["status"] == "success":
       print(f"File successfully quarantined: {result['quarantine_path']}")
       print(f"SHA-256: {result['sha256']}")
   else:
       print(f"Quarantine failed: {result.get('reason', 'Unknown error')}")
   ```

2. **Quarantine Management**
   - Track quarantined samples inventory
   - Apply retention policies
   - Implement regular integrity checks
   - Control access to quarantine storage
   - Document quarantine status changes

   ```python
   # List all quarantined files for an incident
   quarantined_files = containment.list_quarantined_files()

   print(f"Quarantined files for incident {containment.incident_id}:")
   for i, file in enumerate(quarantined_files, 1):
       print(f"{i}. {file.get('file_name', 'Unknown')} - {file.get('timestamp', 'Unknown')}")
       print(f"   SHA-256: {file.get('sha256', 'N/A')}")
       print(f"   Quarantine path: {file.get('quarantine_path', 'Unknown')}")
       print(f"   Encrypted: {file.get('encrypted', False)}")
   ```

3. **Quarantine Restoration Procedure**
   - Verify restoration authorization
   - Determine appropriate restoration location
   - Handle decryption securely
   - Verify file integrity after restoration
   - Document restoration activities

   ```python
   # Restore a quarantined file when needed (requires authorization)
   result = containment.restore_quarantined_file(
       quarantine_path="/secure/quarantine/20230715_134522_suspicious_file.exe",
       restore_path="/secure/analysis/restored_files/suspicious_file.exe",
       decrypt=True
   )

   if result["status"] == "success":
       print(f"File successfully restored to: {result['restore_path']}")
   else:
       print(f"Restoration failed: {result.get('error', 'Unknown error')}")
   ```

### Quarantine Storage Security

1. **Directory Security**
   - Apply restricted file system permissions
   - Implement access auditing
   - Isolate quarantine storage from production
   - Use secure file system encryption
   - Configure tamper detection

2. **Encryption Implementation**
   - Use industry standard encryption algorithms
   - Implement secure key management
   - Protect encryption keys with strong access controls
   - Rotate encryption keys periodically
   - Document encryption procedures

3. **Access Management**
   - Implement principle of least privilege
   - Use time-limited access when possible
   - Require justification for access
   - Maintain detailed access logs
   - Review access regularly

## Implementation Reference

### Command Line Usage

```bash
# Securely quarantine suspicious file
python -m admin.security.incident_response_kit.malware_containment quarantine \
  --file /path/to/suspicious_file.exe \
  --encrypt \
  --incident-id IR-2023-042 \
  --analyst "security_analyst" \
  --quarantine-dir /secure/quarantine

# List quarantined files for an incident
python -m admin.security.incident_response_kit.malware_containment list \
  --incident-id IR-2023-042 \
  --quarantine-dir /secure/quarantine

# Restore a quarantined file (with proper authorization)
python -m admin.security.incident_response_kit.malware_containment restore \
  --file /secure/quarantine/20230715_134522_suspicious_file.exe \
  --restore-path /secure/analysis/restored_files/suspicious_file.exe \
  --incident-id IR-2023-042
```

### Integration with Incident Response Kit

```python
from admin.security.incident_response_kit import malware_containment
from admin.security.incident_response_kit.incident_constants import IncidentSeverity, IncidentType
from admin.security.incident_response_kit import initialize_incident

# Example workflow for handling suspicious file during incident
def handle_suspicious_file(file_path, incident_id, analyst):
    # Initialize containment
    containment = malware_containment.MalwareContainment(
        incident_id=incident_id,
        analyst=analyst
    )

    # Verify toolkit integrity
    if not containment.verify_integrity():
        print("WARNING: Toolkit integrity check failed, proceed with caution")

    # Quarantine the suspicious file
    quarantine_result = containment.quarantine_file(
        file_path=file_path,
        encrypt=True,
        metadata={
            "collection_time": datetime.now(timezone.utc).isoformat(),
            "collector": analyst
        }
    )

    if quarantine_result["status"] != "success":
        return {"status": "failed", "reason": quarantine_result.get("reason")}

    # Analyze the quarantined file
    analysis_result = containment.analyze_file(
        file_path=quarantine_result["quarantine_path"],
        detailed=True
    )

    # Determine severity based on analysis
    severity = IncidentSeverity.MEDIUM
    if analysis_result.get("risk_level") == "critical":
        severity = IncidentSeverity.CRITICAL
    elif analysis_result.get("risk_level") == "high":
        severity = IncidentSeverity.HIGH

    # Create or update incident
    incident = initialize_incident(
        title=f"Malicious File Analysis - {analysis_result.get('file_name')}",
        incident_type=IncidentType.MALWARE,
        severity=severity,
        affected_systems=[quarantine_result.get("metadata", {}).get("source_system", "unknown")],
        initial_details=f"Malicious file detected with risk level: {analysis_result.get('risk_level')}",
        detection_source="Manual Analysis",
        assigned_to=analyst
    )

    return {
        "status": "success",
        "quarantine_result": quarantine_result,
        "analysis_result": analysis_result,
        "incident": incident
    }
```

### Standard Operating Procedure Template

```python
from admin.security.incident_response_kit import malware_containment
import os
import logging
import json

logging.basicConfig(level=logging.INFO)
logger = logging.getLogger("malware_handling_sop")

def malware_sample_handling_procedure(
    file_path,
    incident_id,
    analyst,
    quarantine_dir=None,
    analysis_required=True,
    metadata=None
):
    """
    Standard operating procedure for handling malware samples.

    Args:
        file_path: Path to suspected malware file
        incident_id: Associated incident ID
        analyst: Name of analyst handling the file
        quarantine_dir: Optional custom quarantine location
        analysis_required: Whether to perform analysis
        metadata: Optional metadata about the file

    Returns:
        Dictionary with handling results
    """
    results = {
        "file_path": file_path,
        "incident_id": incident_id,
        "analyst": analyst,
        "timestamp": datetime.now(timezone.utc).isoformat(),
        "steps_completed": []
    }

    try:
        # 1. Validate file exists
        if not os.path.isfile(file_path):
            return {"status": "failed", "reason": "File not found"}
        results["steps_completed"].append("file_validation")

        # 2. Initialize containment
        containment = malware_containment.MalwareContainment(
            incident_id=incident_id,
            quarantine_dir=quarantine_dir,
            analyst=analyst
        )
        results["steps_completed"].append("containment_initialization")

        # 3. Calculate hashes before quarantine
        try:
            hashes = containment.calculate_hashes(file_path)
            results["original_hashes"] = hashes
            results["steps_completed"].append("hash_calculation")
        except Exception as e:
            logger.error(f"Hash calculation failed: {e}")
            results["hash_error"] = str(e)

        # 4. Quarantine the file
        quarantine_result = containment.quarantine_file(
            file_path=file_path,
            metadata=metadata,
            encrypt=True
        )

        if quarantine_result["status"] != "success":
            results["status"] = "failed"
            results["reason"] = quarantine_result.get("reason", "Quarantine failed")
            return results

        results["quarantine_result"] = quarantine_result
        results["steps_completed"].append("quarantine")

        # 5. Analyze if required
        if analysis_required:
            analysis_result = containment.analyze_file(
                file_path=quarantine_result["quarantine_path"],
                detailed=True
            )
            results["analysis_result"] = analysis_result
            results["steps_completed"].append("analysis")

        results["status"] = "success"
        return results

    except Exception as e:
        logger.error(f"Malware handling procedure failed: {e}")
        results["status"] = "failed"
        results["error"] = str(e)
        results["last_completed_step"] = results["steps_completed"][-1] if results["steps_completed"] else "none"
        return results
```

## Available Functions

### MalwareContainment Class

```python
from admin.security.incident_response_kit import malware_containment
```

#### Core Functions

- **`quarantine_file()`** - Safely quarantine a suspected malicious file
  - Parameters:
    - `file_path`: Path to the file to quarantine
    - `metadata`: Optional metadata about the file
    - `encrypt`: Whether to encrypt the quarantined file
  - Returns: Dictionary containing quarantine information including the new location

- **`restore_quarantined_file()`** - Restore a previously quarantined file
  - Parameters:
    - `quarantine_path`: Path to quarantined file
    - `restore_path`: Path to restore file to (optional)
    - `decrypt`: Whether to decrypt the file
  - Returns: Dictionary with restoration results

- **`list_quarantined_files()`** - List all files quarantined for a specific incident
  - Parameters: None
  - Returns: List of dictionaries with quarantined file information

- **`analyze_file()`** - Analyze a suspicious file for malicious content
  - Parameters:
    - `file_path`: Path to suspicious file
    - `detailed`: Whether to perform detailed analysis
  - Returns: Dictionary with analysis results including risk level and indicators

#### Utility Functions

- **`calculate_hashes()`** - Calculate cryptographic hashes for a file
  - Parameters:
    - `file_path`: Path to the file
  - Returns: Dictionary with MD5, SHA-1, and SHA-256 hashes

- **`contains_malware_signatures()`** - Check if file matches known malware signatures
  - Parameters:
    - `file_path`: Path to the file to check
  - Returns: Dictionary with signature match results

- **`verify_integrity()`** - Verify the integrity of the toolkit
  - Parameters: None
  - Returns: Boolean indicating if integrity check passed

- **`isolate_process()`** - Isolate a suspicious process
  - Parameters:
    - `pid`: Process ID to isolate
    - `method`: Isolation method (suspend, terminate, isolate)
    - `force`: Whether to force operation on critical processes
  - Returns: Dictionary with isolation results

### Constants

```python
from admin.security.incident_response_kit.malware_containment import SAFE_EXTENSIONS, HIGH_RISK_EXTENSIONS
```

- **`SAFE_EXTENSIONS`** - Set of file extensions considered safe
  - Examples: `.txt`, `.log`, `.json`, `.csv`, `.xml`, `.md`, `.yml`, `.yaml`

- **`HIGH_RISK_EXTENSIONS`** - Set of high-risk file extensions
  - Examples: `.exe`, `.dll`, `.bat`, `.ps1`, `.vbs`, `.js`, `.hta`, `.scr`, `.pif`, `.com`

### Exception Classes

```python
from admin.security.incident_response_kit.malware_containment import (
    MalwareContainmentError,
    QuarantineError,
    AnalysisError,
    ValidationError
)
```

- **`MalwareContainmentError`** - Base exception for all malware containment errors
- **`QuarantineError`** - Error during file quarantine operations
- **`AnalysisError`** - Error during malware analysis operations
- **`ValidationError`** - Error during validation of parameters or files

## Best Practices & Security

- **Principle of Least Privilege**: Handle malware with minimal required access rights
- **Defense in Depth**: Apply multiple security controls to contain malware
- **Isolation First**: Always prioritize isolation before detailed analysis
- **Evidence Preservation**: Maintain forensic integrity of samples at all times
- **Documentation Discipline**: Document all handling activities and maintain chain of custody
- **Safe Analysis**: Never analyze malware on production systems
- **Encryption by Default**: Always encrypt malware samples when stored
- **Access Control**: Strictly limit access to malware samples and related data
- **Verification**: Always verify file integrity after transfers or operations
- **Secure Deletion**: Implement secure deletion procedures when samples are no longer needed
- **Authorization**: Require formal authorization for sample access and handling
- **Environmental Controls**: Maintain proper physical and logical isolation for analysis
- **Tool Security**: Regularly update and verify analysis tools
- **Professional Development**: Ensure handlers receive proper training
- **Risk Assessment**: Conduct risk assessment before handling high-risk samples

## Related Documentation

- Malware Analysis Guide - Comprehensive malware analysis methodology
- Evidence Collection Guide - Procedures for collecting digital evidence
- Chain of Custody Template - Template for documenting evidence handling
- Malware Incident Response Playbook - Detailed malware response procedures
- [NIST SP 800-61: Computer Security Incident Handling Guide](https://csrc.nist.gov/publications/detail/sp/800-61/rev-2/final)
- [NIST SP 800-86: Guide to Integrating Forensic Techniques into Incident Response](https://csrc.nist.gov/publications/detail/sp/800-86/final)
- [CISA Malware Analysis Report Guidelines](https://www.cisa.gov/sites/default/files/publications/MAR_10_GUI_v1_White.pdf)
