# Malware Analysis Guide

## Contents

- [Overview](#overview)
- [Analysis Environment Setup](#analysis-environment-setup)
- [Initial Triage](#initial-triage)
- [Static Analysis](#static-analysis)
- [Dynamic Analysis](#dynamic-analysis)
- [Memory Analysis](#memory-analysis)
- [Network Traffic Analysis](#network-traffic-analysis)
- [Indicators of Compromise Extraction](#indicators-of-compromise-extraction)
- [Analysis Documentation](#analysis-documentation)
- [Implementation Reference](#implementation-reference)
- [Available Functions](#available-functions)
- [Best Practices & Security](#best-practices--security)
- [Related Documentation](#related-documentation)

## Overview

This guide provides structured methodologies for analyzing malware during security incidents. It covers essential malware analysis techniques, tools, and workflows designed for security analysts responding to malware-related incidents. The guide follows industry best practices while leveraging the platform's built-in malware analysis and containment capabilities.

Malware analysis is a critical component of effective incident response, enabling responders to:

- Determine the capabilities and impact of malicious code
- Extract indicators of compromise for detection and prevention
- Assess data exfiltration and system compromise
- Develop effective containment and eradication strategies
- Support attribution and threat intelligence efforts

## Analysis Environment Setup

### Isolated Environment Requirements

1. **Virtual Machine Configuration**
   - Isolated host-only network
   - No shared folders with host
   - Disabled clipboard sharing
   - Snapshot capability before analysis
   - Similar OS/application versions to production
   - Limited resources to slow malware execution

2. **Physical Isolation Options**
   - Air-gapped system
   - Separate network segment
   - Hardware write blockers for forensic acquisition
   - Dedicated analysis hardware
   - Physical network monitoring devices

3. **Required Analysis Tools**
   - Static analysis utilities
   - Debugging tools
   - Network monitoring tools
   - Memory acquisition tools
   - System monitoring utilities
   - Disassemblers and decompilers

4. **Tool Installation**
   - Install core analysis toolkit:

   ```bash
   # Ensure toolkit is available and integrity-verified
   cd admin/security/incident_response_kit
   ./initialize.sh --prepare-analysis-environment
   ```

### Environment Isolation with MalwareContainment

```python
from admin.security.incident_response_kit import malware_containment

# Initialize containment with specific quarantine directory
containment = malware_containment.MalwareContainment(
    incident_id="IR-2023-042",
    quarantine_dir="/secure/analysis/quarantine",
    analyst="security_analyst"
)

# Verify toolkit integrity
integrity_status = containment.verify_integrity()
if not integrity_status:
    print("WARNING: Toolkit integrity verification failed, analysis results may be compromised")
```

### Safety Controls

1. **Host System Protection**
   - Enable application whitelisting
   - Implement network isolation
   - Update antivirus definitions
   - Disable autorun features
   - Use non-administrator accounts

2. **Network Controls**
   - Implement IDS/IPS monitoring
   - Configure fake services if needed
   - Enable full packet capture
   - Implement DNS sinkholing
   - Set up traffic throttling

3. **Evidence Protection**
   - Create forensic copies of samples
   - Implement file integrity monitoring
   - Maintain chain of custody documentation
   - Secure storage of malware samples
   - Regular backup of analysis results

## Initial Triage

### Sample Acquisition and Handling

1. **Sample Collection Process**
   - Securely collect suspicious files
   - Maintain chain of custody
   - Document source location and context
   - Generate file hashes immediately
   - Package securely with appropriate warning labels

2. **Sample Metadata Collection**
   - Timestamp of discovery
   - System/location of origin
   - Associated user accounts
   - Related incidents or alerts
   - Suspected infection vector

3. **File Quarantine Process**

```python
# Quarantine suspicious file while preserving metadata
result = containment.quarantine_file(
    file_path="/path/to/suspicious_file.exe",
    metadata={
        "source_system": "DESKTOP-HR001",
        "user_context": "jsmith",
        "alert_id": "AV-42391"
    },
    encrypt=True
)

if result["status"] == "success":
    print(f"File quarantined at: {result['quarantine_path']}")
    print(f"SHA-256: {result['sha256']}")
```

### Initial Assessment

1. **File Properties Analysis**
   - Check file size and type
   - Verify file extension matches type
   - Calculate and verify hash values (MD5, SHA-1, SHA-256)
   - Check file header and structure
   - Extract file metadata

2. **Preliminary Risk Assessment**
   - Check against known malware signatures
   - Assess file reputation via threat intelligence
   - Evaluate file characteristics for suspicious properties
   - Review associated alerts and detection context
   - Determine priority based on potential impact

3. **Quick Scan Implementation**

```python
# Perform basic malware signature check
signature_check = containment.contains_malware_signatures("/path/to/suspicious_file.exe")

# Evaluate risk level
if signature_check["contains_signatures"]:
    print(f"WARNING: File matches {len(signature_check['signatures_found'])} malware signatures")
    print(f"Risk level: {signature_check['risk_level']}")

    # Show matched signatures
    for sig in signature_check["signatures_found"]:
        print(f"Match: {sig['name']} ({', '.join(sig['tags'])})")
```

## Static Analysis

### Basic Static Analysis Techniques

1. **Hash Calculation and Verification**
   - Generate MD5, SHA-1, and SHA-256 hashes
   - Check hashes against reputation databases
   - Compare against known-good file hashes
   - Document all hash values for reporting
   - Store hashes for IOC development

2. **File Type Identification**
   - Verify true file type vs. extension
   - Check for file type anomalies
   - Identify executable format (PE, ELF, etc.)
   - Detect possible nested formats
   - Identify file format obfuscation techniques

3. **Strings Analysis**
   - Extract ASCII and Unicode strings
   - Identify suspicious URLs and IP addresses
   - Look for unusual function calls
   - Detect encoded strings or commands
   - Identify evasion or obfuscation patterns

4. **Implementation Example**

```python
# Perform comprehensive static analysis
analysis_result = containment.analyze_file(
    file_path="/secure/evidence/IR-2023-042/suspicious_file.exe",
    detailed=True
)

# Extract critical information
file_info = {
    "sha256": analysis_result.get("sha256"),
    "file_type": analysis_result.get("file_type"),
    "is_executable": analysis_result.get("is_executable"),
    "risk_level": analysis_result.get("risk_level")
}

# Check suspicious strings found
if analysis_result.get("suspicious_strings_count", 0) > 0:
    print(f"\nSuspicious strings found: {analysis_result.get('suspicious_strings_count')}")

    # Check for network indicators (potential C2)
    network_iocs = analysis_result.get("category_matches", {}).get("network", [])
    if network_iocs:
        print("Potential network indicators:")
        for ioc in network_iocs[:5]:
            print(f"  - {ioc}")
```

### Advanced Static Analysis Techniques

1. **PE File Analysis**
   - Examine PE header structures
   - Analyze section characteristics
   - Check import/export tables
   - Investigate resources
   - Identify compiler information
   - Check digital signatures
   - Detect abnormal PE header characteristics

2. **Code Disassembly**
   - Identify key functionality
   - Analyze control flow
   - Detect anti-analysis techniques
   - Map API calls and libraries
   - Document suspicious code constructs
   - Identify encryption algorithms

3. **Obfuscation Analysis**
   - Identify packers or protectors
   - Detect code obfuscation techniques
   - Analyze entropy for encrypted sections
   - Identify anti-debugging/anti-VM measures
   - Detect string encryption/encoding methods

4. **Advanced Static Analysis Implementation**

```python
# For advanced analysis, use specialized modules when available
try:
    from admin.security.forensics.static_analysis import pe_analyzer

    # Perform in-depth PE analysis
    pe_results = pe_analyzer.analyze_pe_file(
        file_path="/secure/evidence/IR-2023-042/suspicious_file.exe",
        extract_resources=True,
        detect_packers=True,
        analyze_imports=True,
        check_signatures=True
    )

    # Check for signs of evasion
    evasion_techniques = pe_results.get("evasion_techniques", [])
    if evasion_techniques:
        print("Detected evasion techniques:")
        for technique in evasion_techniques:
            print(f"  - {technique['name']}: {technique['description']}")

    # Check for potential code injection capabilities
    if pe_results.get("capabilities", {}).get("code_injection", False):
        print("WARNING: File has potential code injection capabilities")

except ImportError:
    print("Advanced PE analysis module not available")
```

### YARA Rule Analysis

1. **Using Existing YARA Rules**
   - Apply standard malware rule sets
   - Use threat actor-specific rules
   - Implement behavior-based rules
   - Check against MITRE ATT&CK rules
   - Apply environment-specific custom rules

2. **YARA Rule Development**
   - Create rules based on unique strings
   - Define rules for code patterns
   - Implement rules for specific behaviors
   - Create contextual pattern matching
   - Test rules against known samples

3. **YARA Implementation**

```python
# Check if file matches existing YARA rules
yara_matches = analysis_result.get("yara_matches", [])

if yara_matches:
    print(f"\nYARA matches found: {len(yara_matches)}")
    for match in yara_matches:
        print(f"Rule: {match.get('rule')}")
        print(f"  Tags: {', '.join(match.get('tags', []))}")

        # Print metadata if available
        if match.get('meta'):
            print("  Metadata:")
            for key, value in match.get('meta', {}).items():
                print(f"    {key}: {value}")
```

## Dynamic Analysis

### Controlled Execution Environment

1. **Safe Execution Preparation**
   - Prepare isolated VM with monitoring tools
   - Take clean system snapshot
   - Configure network monitoring
   - Set up runtime activity logging
   - Prepare memory analysis tools

2. **System Monitoring Setup**
   - Process monitoring
   - File system activity tracking
   - Registry monitoring
   - Network traffic capture
   - API call hooking
   - Memory allocation tracking

3. **Detonation Procedures**
   - Execute sample with controlled privileges
   - Monitor initial activities
   - Allow execution time for delayed actions
   - Trigger potential environment checks
   - Document all observed behaviors
   - Capture changes to system state

4. **Automated Sandbox Analysis**

```python
from admin.security.forensics import sandbox_analyzer

# Submit sample to sandbox for automated analysis
sandbox_results = sandbox_analyzer.analyze_sample(
    file_path="/secure/evidence/IR-2023-042/suspicious_file.exe",
    execution_time=120,  # Run for 120 seconds
    capture_network=True,
    system_activity_monitoring=True,
    simulated_user_activity=True
)

# Check for key malicious behaviors
if sandbox_results.get("behaviors"):
    print("\nMalicious behaviors detected:")
    for behavior in sandbox_results.get("behaviors", []):
        print(f"  - {behavior['category']}: {behavior['description']}")
        print(f"    Confidence: {behavior['confidence']}")
```

### Behavioral Analysis

1. **Process Activity Analysis**
   - Track process creation
   - Monitor process relationships
   - Document injection techniques
   - Analyze process privileges
   - Identify suspicious process behaviors
   - Monitor process network activity

2. **File System Analysis**
   - Track file creation/modification
   - Identify dropped files
   - Monitor temporary files
   - Document file deletion activities
   - Detect file attribute changes
   - Identify persistence mechanisms via filesystem

3. **Registry Analysis**
   - Monitor registry modifications
   - Identify persistence mechanisms
   - Track configuration changes
   - Document credential storage activity
   - Identify defense evasion techniques

4. **Network Activity Analysis**
   - Capture all network traffic
   - Identify C2 communication
   - Detect data exfiltration
   - Monitor DNS queries
   - Identify encrypted traffic patterns
   - Document beaconing behaviors

### Advanced Dynamic Analysis

1. **API Call Tracing**
   - Monitor system API calls
   - Track cryptography usage
   - Document network-related APIs
   - Identify anti-analysis API usage
   - Monitor privilege-related APIs

2. **Debugger Analysis**
   - Set breakpoints at key functions
   - Analyze control flow
   - Examine memory at runtime
   - Monitor parameter values
   - Identify evasion techniques

3. **Memory Forensics**
   - Capture memory during execution
   - Analyze injected code
   - Identify hidden processes
   - Extract unencrypted content
   - Document memory artifacts

4. **Advanced Dynamic Analysis Implementation**

```python
from admin.security.forensics import api_monitor, memory_analyzer

# Monitor specific API calls during execution
api_results = api_monitor.trace_execution(
    file_path="/secure/evidence/IR-2023-042/suspicious_file.exe",
    api_categories=["network", "crypto", "process", "anti-analysis"],
    execution_time=180
)

# Check for key API indicators
if api_results.get("api_summary"):
    print("\nKey API calls detected:")
    for category, calls in api_results.get("api_summary").items():
        print(f"\n{category.upper()} APIs:")
        for api_call in calls[:5]:  # Show top 5
            print(f"  - {api_call['name']}")
            print(f"    Args: {api_call['args']}")
            print(f"    Count: {api_call['count']}")

# Capture and analyze memory after execution
memory_capture = memory_analyzer.capture_process_memory(
    process_name=api_results.get("process_name"),
    output_file="/secure/evidence/IR-2023-042/memory_dump.dmp"
)

# Extract strings from memory
memory_strings = memory_analyzer.extract_memory_strings(
    memory_dump="/secure/evidence/IR-2023-042/memory_dump.dmp",
    min_length=8
)

# Find potential passwords, tokens or keys in memory
print("\nPotential sensitive data in memory:")
for string in memory_strings.get("potential_credentials", [])[:5]:
    print(f"  - {string}")
```

## Memory Analysis

### Memory Acquisition

1. **Live Memory Acquisition**
   - Capture process memory
   - Acquire full system memory
   - Document acquisition parameters
   - Preserve memory image integrity
   - Calculate memory image hashes

2. **Memory Acquisition Tools**
   - Built-in memory capture utilities
   - Commercial forensic tools
   - Open-source acquisition tools
   - Hardware-based acquisition methods
   - Hypervisor-based capture methods

3. **Memory Acquisition Implementation**

```python
from admin.security.forensics import memory_acquisition

# Capture memory from infected system
memory_result = memory_acquisition.capture_system_memory(
    output_path="/secure/evidence/IR-2023-042/memory/",
    format="raw",
    compress=True,
    calculate_hashes=True
)

print(f"Memory captured to: {memory_result['output_file']}")
print(f"SHA-256: {memory_result['sha256']}")
print(f"Acquisition method: {memory_result['acquisition_method']}")
```

### Memory Analysis Techniques

1. **Process Analysis**
   - Identify running processes
   - Examine process relationships
   - Detect hidden processes
   - Analyze process memory regions
   - Extract process artifacts

2. **Memory Artifact Extraction**
   - Extract strings and patterns
   - Recover network artifacts
   - Identify loaded modules
   - Extract encryption keys
   - Recover command history

3. **Code Injection Analysis**
   - Detect injected code
   - Identify hooking techniques
   - Locate shellcode in memory
   - Analyze process hollowing
   - Examine reflective loading

4. **Memory Analysis Implementation**

```python
from admin.security.forensics import volatility_analyzer

# Analyze memory dump using Volatility
analysis_results = volatility_analyzer.analyze_memory_dump(
    memory_file="/secure/evidence/IR-2023-042/memory/system.raw",
    plugins=[
        "pslist", "pstree", "malfind",
        "netscan", "cmdline", "shellcode_detector",
        "ldrmodules", "dlllist"
    ]
)

# Check for malicious processes
malicious_processes = analysis_results.get("malfind", {}).get("results", [])
if malicious_processes:
    print("\nPotentially malicious memory regions detected:")
    for process in malicious_processes:
        print(f"  - Process: {process['process_name']} (PID: {process['pid']})")
        print(f"    Memory region: {process['address']} ({process['size']} bytes)")
        print(f"    Protection: {process['protection']}")
        print(f"    Characteristics: {process['characteristics']}")
```

### Rootkit and Persistence Detection

1. **Kernel Object Analysis**
   - Detect DKOM attacks
   - Analyze kernel hooks
   - Identify driver modifications
   - Detect IRP table hooks
   - Check for SSDT hooking

2. **Registry Analysis in Memory**
   - Extract registry from memory
   - Identify persistence keys
   - Find autoruns in registry
   - Detect registry modifications
   - Compare with on-disk registry

3. **Persistence Detection Implementation**

```python
# Check for persistence mechanisms
persistence = volatility_analyzer.detect_persistence(
    memory_file="/secure/evidence/IR-2023-042/memory/system.raw",
    check_registry=True,
    check_wmi=True,
    check_services=True,
    check_scheduled_tasks=True
)

# Display identified persistence mechanisms
if persistence.get("mechanisms", []):
    print("\nPersistence mechanisms identified:")
    for mechanism in persistence.get("mechanisms", []):
        print(f"  - Type: {mechanism['type']}")
        print(f"    Location: {mechanism['location']}")
        print(f"    Executable: {mechanism['executable']}")
        print(f"    Privileges: {mechanism['privileges']}")
```

## Network Traffic Analysis

### Traffic Capture Methods

1. **Full Packet Capture**
   - Configure span/mirror ports
   - Deploy network taps
   - Set up in-line capture
   - Configure packet filters
   - Implement packet storage

2. **Flow Data Analysis**
   - Collect NetFlow/IPFIX records
   - Monitor connection metadata
   - Track session information
   - Analyze traffic patterns
   - Identify unusual destinations

3. **Implementing Network Capture**

```python
from admin.security.incident_response_kit import traffic_analysis

# Capture network traffic
capture_result = traffic_analysis.capture_traffic(
    interface="eth0",
    duration=300,  # 5 minutes
    filter="host 192.168.1.100",  # Target infected host
    output_file="/secure/evidence/IR-2023-042/network/capture.pcap"
)

print(f"Captured {capture_result['packet_count']} packets")
print(f"Capture file: {capture_result['output_file']}")
print(f"Capture size: {capture_result['file_size']} bytes")
```

### Malware Network Behavior Analysis

1. **Command & Control (C2) Detection**
   - Identify beaconing patterns
   - Detect domain generation algorithms
   - Monitor abnormal DNS queries
   - Analyze TLS certificate anomalies
   - Identify traffic timing patterns

2. **Data Exfiltration Analysis**
   - Detect large outbound transfers
   - Identify unusual protocols
   - Monitor encrypted traffic anomalies
   - Analyze DNS tunneling
   - Check for steganography techniques

3. **Network Behavior Implementation**

```python
# Analyze captured traffic for C2 communications
c2_analysis = traffic_analysis.analyze_c2_traffic(
    pcap_file="/secure/evidence/IR-2023-042/network/capture.pcap",
    check_beaconing=True,
    check_dga=True,
    check_tunneling=True
)

# Display potential C2 findings
if c2_analysis.get("potential_c2", []):
    print("\nPotential C2 communications detected:")
    for c2 in c2_analysis.get("potential_c2", []):
        print(f"  - Destination: {c2['destination']}")
        print(f"    Protocol: {c2['protocol']}")
        print(f"    Confidence: {c2['confidence']}")
        print(f"    Pattern: {c2['pattern']}")
        print(f"    Data transferred: {c2['bytes_transferred']} bytes")
```

### Protocol Analysis

1. **HTTP/HTTPS Analysis**
   - Examine request/response patterns
   - Check for suspicious User-Agents
   - Analyze URL patterns
   - Monitor HTTP headers
   - Decode HTTP payloads

2. **DNS Traffic Analysis**
   - Identify suspicious domain queries
   - Check for high query volume
   - Detect DNS tunneling
   - Analyze domain entropy
   - Monitor domain age and reputation

3. **Other Protocol Analysis**
   - Examine uncommon protocol usage
   - Detect protocol anomalies
   - Analyze encrypted traffic patterns
   - Identify non-standard ports
   - Monitor application layer behavior

4. **Protocol Analysis Implementation**

```python
# Analyze HTTP traffic
http_analysis = traffic_analysis.analyze_http_traffic(
    pcap_file="/secure/evidence/IR-2023-042/network/capture.pcap"
)

# Display suspicious HTTP traffic
if http_analysis.get("suspicious_requests", []):
    print("\nSuspicious HTTP requests detected:")
    for request in http_analysis.get("suspicious_requests", []):
        print(f"  - URL: {request['url']}")
        print(f"    User-Agent: {request['user_agent']}")
        print(f"    Method: {request['method']}")
        print(f"    Status: {request['status']}")
        if request.get("suspicious_elements"):
            print(f"    Suspicious elements: {', '.join(request['suspicious_elements'])}")

# Analyze DNS traffic
dns_analysis = traffic_analysis.analyze_dns_traffic(
    pcap_file="/secure/evidence/IR-2023-042/network/capture.pcap",
    check_reputation=True
)

# Display suspicious DNS queries
if dns_analysis.get("suspicious_queries", []):
    print("\nSuspicious DNS queries detected:")
    for query in dns_analysis.get("suspicious_queries", []):
        print(f"  - Domain: {query['domain']}")
        print(f"    Query type: {query['query_type']}")
        print(f"    Resolved IP: {query.get('resolved_ip', 'N/A')}")
        print(f"    Reputation: {query.get('reputation', 'Unknown')}")
        if query.get("entropy_score"):
            print(f"    Entropy score: {query['entropy_score']}")
```

## Indicators of Compromise Extraction

### IOC Types and Extraction

1. **File-Based IOCs**
   - File hashes (MD5, SHA-1, SHA-256)
   - File names and paths
   - File sizes and types
   - File attributes and metadata
   - Embedded file artifacts

2. **Network-Based IOCs**
   - IP addresses
   - Domain names
   - URLs and URI patterns
   - Network traffic patterns
   - C2 protocols and signatures
   - User-Agent strings

3. **Host-Based IOCs**
   - Registry keys and values
   - Scheduled tasks
   - Service entries
   - WMI objects
   - Process names and attributes
   - Memory patterns

4. **IOC Extraction Implementation**

```python
from admin.security.incident_response_kit import ioc_extractor

# Extract IOCs from all analysis data
iocs = ioc_extractor.extract_iocs(
    analysis_data={
        "static": analysis_result,
        "dynamic": sandbox_results if 'sandbox_results' in locals() else {},
        "network": c2_analysis if 'c2_analysis' in locals() else {},
        "memory": analysis_results if 'analysis_results' in locals() else {}
    },
    dedup=True,
    min_confidence="medium"
)

# Display extracted IOCs by category
print("\nExtracted Indicators of Compromise:")
for category, indicators in iocs.items():
    print(f"\n{category.upper()} indicators ({len(indicators)}):")
    for ioc in indicators[:5]:  # Show top 5 of each type
        print(f"  - {ioc['value']}")
        print(f"    Confidence: {ioc['confidence']}")
        print(f"    Context: {ioc['context']}")
    if len(indicators) > 5:
        print(f"  ... and {len(indicators) - 5} more")

# Export IOCs in STIX format
ioc_extractor.export_iocs(
    iocs=iocs,
    format="stix2",
    output_file="/secure/evidence/IR-2023-042/iocs/stix_indicators.json",
    include_context=True
)
```

### IOC Enrichment

1. **Threat Intelligence Enrichment**
   - Check reputation databases
   - Search threat intelligence platforms
   - Verify against known actor TTPs
   - Add MITRE ATT&CK mappings
   - Include confidence scoring

2. **Context Addition**
   - Document discovery method
   - Add impact assessment
   - Include behavioral context
   - Document related indicators
   - Assess false positive likelihood

3. **IOC Enrichment Implementation**

```python
# Enrich IOCs with threat intelligence
enriched_iocs = ioc_extractor.enrich_iocs(
    iocs=iocs,
    ti_sources=["internal_ti", "alienvault", "virustotal"],
    include_mitre=True
)

# Display enrichment results
print("\nThreat Intelligence Enrichment Results:")
for category, indicators in enriched_iocs.items():
    enriched_count = sum(1 for ioc in indicators if ioc.get('ti_data'))
    if enriched_count:
        print(f"\n{category.upper()}: {enriched_count} indicators enriched with threat intel")

        # Show a few examples
        for ioc in [i for i in indicators if i.get('ti_data')][:3]:
            print(f"  - {ioc['value']}:")
            print(f"    Reputation: {ioc['ti_data'].get('reputation', 'Unknown')}")
            if ioc['ti_data'].get('actor'):
                print(f"    Threat Actor: {ioc['ti_data']['actor']}")
            if ioc['ti_data'].get('mitre_techniques'):
                print(f"    MITRE ATT&CK: {', '.join(ioc['ti_data']['mitre_techniques'])}")
```

### Detection Rule Development

1. **YARA Rule Creation**
   - Develop rules based on file artifacts
   - Focus on unique strings and byte sequences
   - Include contextual conditions
   - Document rule logic and testing
   - Set appropriate metadata

2. **Network Detection Rule Creation**
   - Develop Snort/Suricata rules
   - Create Zeek/Bro detection scripts
   - Implement firewall block rules
   - Develop proxy detection signatures
   - Create SIEM correlation rules

3. **Host-Based Detection Rules**
   - Create EDR detection rules
   - Develop sysmon configurations
   - Create registry monitoring rules
   - Implement log-based detection
   - Develop application control rules

4. **Rule Development Implementation**

```python
from admin.security.incident_response_kit import rule_generator

# Generate YARA rule from malware sample
yara_rule = rule_generator.create_yara_rule(
    sample_path="/secure/evidence/IR-2023-042/suspicious_file.exe",
    rule_name="Malware_IR2023_042",
    author="Security Team",
    description="Detection rule for malware found in IR-2023-042",
    strings_min_length=6,
    strings_max_count=20,
    include_file_characteristics=True
)

# Save YARA rule to file
with open("/secure/evidence/IR-2023-042/detection/malware_detection.yar", "w") as f:
    f.write(yara_rule)

# Generate Snort/Suricata rule from network traffic
network_rule = rule_generator.create_network_rule(
    pcap_file="/secure/evidence/IR-2023-042/network/capture.pcap",
    rule_type="suricata",
    msg="Detected C2 traffic from IR-2023-042",
    sid=5000042,
    rev=1
)

# Save network detection rule
with open("/secure/evidence/IR-2023-042/detection/network_detection.rules", "w") as f:
    f.write(network_rule)
```

## Analysis Documentation

### Report Structure

1. **Executive Summary**
   - Key findings
   - Malware classification
   - Threat actor association (if known)
   - Business impact assessment
   - Recommended actions

2. **Technical Analysis**
   - Sample information
   - Static analysis results
   - Dynamic analysis findings
   - Memory analysis observations
   - Network traffic analysis
   - Notable TTPs identified

3. **Indicators of Compromise**
   - File indicators
   - Network indicators
   - Host-based indicators
   - Detection rules and signatures
   - False positive considerations

4. **Remediation Guidance**
   - Required containment actions
   - System cleanup procedures
   - Prevention recommendations
   - Detection improvements
   - Future mitigation strategies

### Documentation Implementation

```python
from admin.security.forensics.templates.analysis_docs import malware_report
from datetime import datetime

# Build comprehensive malware analysis report
report = malware_report.generate_report(
    case_id="IR-2023-042",
    sample_id="MAL-001",
    analyst_name="Security Analyst",
    creation_date=datetime.now(),
    analysis_data={
        "static_analysis": analysis_result,
        "dynamic_analysis": sandbox_results if 'sandbox_results' in locals() else {},
        "network_analysis": c2_analysis if 'c2_analysis' in locals() else {},
        "memory_analysis": analysis_results if 'analysis_results' in locals() else {},
        "extracted_iocs": enriched_iocs if 'enriched_iocs' in locals() else iocs
    },
    include_mitigations=True,
    include_screenshots=True,
    classification="TLP:AMBER"
)

# Save report to file
with open("/secure/evidence/IR-2023-042/reports/malware_analysis_report.md", "w") as f:
    f.write(report)
```

### Evidence Preservation

1. **Evidence Storage**
   - Securely store all analysis artifacts
   - Maintain proper evidence handling
   - Apply appropriate access controls
   - Implement retention policies
   - Maintain hash verification

2. **Chain of Custody**
   - Document all evidence handling
   - Record analyst actions and findings
   - Maintain temporal integrity
   - Document analysis environment
   - Record tools and versions used

3. **Analysis Repeatability**
   - Document analysis methodology
   - Preserve analysis environment details
   - Record tool configurations
   - Maintain logs of all analysis actions
   - Document decision-making process

## Implementation Reference

### Command Line Usage

```bash
# Analyze suspicious file through CLI
python -m admin.security.incident_response_kit.malware_containment analyze \
  --file /path/to/suspicious_file.exe \
  --detailed \
  --incident-id IR-2023-042 \
  --output /secure/evidence/IR-2023-042/analysis_results.json

# Quarantine suspicious file with encryption
python -m admin.security.incident_response_kit.malware_containment quarantine \
  --file /path/to/suspicious_file.exe \
  --encrypt \
  --incident-id IR-2023-042 \
  --quarantine-dir /secure/quarantine

# List quarantined files for an incident
python -m admin.security.incident_response_kit.malware_containment list \
  --incident-id IR-2023-042 \
  --quarantine-dir /secure/quarantine

# Isolate suspicious process
python -m admin.security.incident_response_kit.malware_containment isolate-process \
  12345 \
  --method suspend \
  --incident-id IR-2023-042
```

### Integration with Incident Response Kit

```python
from admin.security.incident_response_kit import malware_containment
from admin.security.incident_response_kit import log_analyzer
from admin.security.incident_response_kit.incident_constants import IncidentSeverity, IncidentType

# Initialize containment
containment = malware_containment.MalwareContainment(
    incident_id="IR-2023-042",
    analyst="security_analyst"
)

# Analyze suspicious file
analysis_result = containment.analyze_file(
    file_path="/path/to/suspicious_file.exe",
    detailed=True
)

# Determine severity based on analysis
severity = IncidentSeverity.MEDIUM
if analysis_result.get("risk_level") == "critical":
    severity = IncidentSeverity.CRITICAL
elif analysis_result.get("risk_level") == "high":
    severity = IncidentSeverity.HIGH

# Create incident and associate with malware
from admin.security.incident_response_kit import initialize_incident

incident = initialize_incident(
    title="Suspicious File Analysis",
    incident_type=IncidentType.MALWARE,
    severity=severity,
    affected_systems=["workstation-15"],
    initial_details="Malicious file detected by endpoint protection",
    detection_source="EDR Alert",
    assigned_to="security-team@example.com"
)

# Link analysis results to incident
incident.add_evidence(
    evidence_type="analysis_result",
    content=analysis_result,
    description="Static and dynamic analysis of suspicious file"
)
```

### Integration with Core Security Module

```python
from core.security import log_security_event
from admin.security.incident_response_kit import malware_containment

# Initialize containment
containment = malware_containment.MalwareContainment(
    incident_id="IR-2023-042",
    analyst="security_analyst"
)

# Analyze suspicious file
analysis_result = containment.analyze_file(
    file_path="/path/to/suspicious_file.exe",
    detailed=True
)

# Log significant findings as security events
if analysis_result.get("risk_level") in ["high", "critical"]:
    log_security_event(
        event_type="malware_detected",
        severity="high",
        description=f"Malicious file detected: {analysis_result.get('file_name')}",
        source_ip="192.168.1.100",  # System where file was found
        resource="endpoint-protection",
        details={
            "file_hash": analysis_result.get("sha256"),
            "risk_level": analysis_result.get("risk_level"),
            "malware_type": analysis_result.get("malware_classification", "unknown"),
            "incident_id": "IR-2023-042"
        }
    )
```

## Available Functions

### Malware Containment Functions

```python
from admin.security.incident_response_kit import malware_containment
```

#### Core Analysis Functions

- **`analyze_file()`** - Analyze suspicious file for malicious content
  - Parameters:
    - `file_path`: Path to suspicious file
    - `detailed`: Whether to perform detailed analysis
  - Returns: Dictionary with analysis results including risk level and indicators

- **`quarantine_file()`** - Safely quarantine suspicious file
  - Parameters:
    - `file_path`: Path to file to quarantine
    - `metadata`: Optional metadata about the file
    - `encrypt`: Whether to encrypt the quarantined file
  - Returns: Dictionary with quarantine results and file information

- **`calculate_hashes()`** - Calculate cryptographic hashes for a file
  - Parameters:
    - `file_path`: Path to the file
  - Returns: Dictionary with MD5, SHA-1, and SHA-256 hashes

- **`restore_quarantined_file()`** - Restore a previously quarantined file
  - Parameters:
    - `quarantine_path`: Path to quarantined file
    - `restore_path`: Path to restore file to (optional)
    - `decrypt`: Whether to decrypt the file
  - Returns: Dictionary with restoration results

- **`list_quarantined_files()`** - List files quarantined for an incident
  - Parameters: None
  - Returns: List of dictionaries with quarantined file information

- **`isolate_process()`** - Isolate a suspicious process
  - Parameters:
    - `pid`: Process ID to isolate
    - `method`: Isolation method (suspend, terminate, isolate)
    - `force`: Whether to force operation on critical processes
  - Returns: Dictionary with isolation results

#### Utility Functions

- **`contains_malware_signatures()`** - Check if file matches known malware signatures
  - Parameters:
    - `file_path`: Path to the file to check
  - Returns: Dictionary with signature match results

- **`verify_integrity()`** - Verify the integrity of the toolkit
  - Parameters: None
  - Returns: Boolean indicating if integrity check passed

### Forensics Static Analysis Functions

```python
from admin.security.forensics.static_analysis import analyze_file, check_malware_signatures
```

- **`analyze_file()`** - Perform comprehensive static file analysis
  - Parameters:
    - `file_path`: Path to file to analyze
    - `include_entropy`: Whether to calculate file entropy
  - Returns: Dictionary with analysis results

- **`check_malware_signatures()`** - Check file against malware signatures
  - Parameters:
    - `file_path`: Path to file to check
  - Returns: Dictionary with signature match results

### Extraction Functions

```python
from admin.security.incident_response_kit import ioc_extractor
```

- **`extract_iocs()`** - Extract indicators of compromise from analysis data
  - Parameters:
    - `analysis_data`: Dictionary with analysis results
    - `dedup`: Whether to remove duplicate IOCs
    - `min_confidence`: Minimum confidence level for IOCs
  - Returns: Dictionary with IOCs categorized by type

- **`enrich_iocs()`** - Enrich IOCs with threat intelligence
  - Parameters:
    - `iocs`: Dictionary with IOCs
    - `ti_sources`: List of threat intelligence sources to use
    - `include_mitre`: Whether to include MITRE ATT&CK mappings
  - Returns: Dictionary with enriched IOCs

- **`export_iocs()`** - Export IOCs to various formats
  - Parameters:
    - `iocs`: Dictionary with IOCs
    - `format`: Export format (stix2, misp, csv, etc.)
    - `output_file`: Path to output file
    - `include_context`: Whether to include context information
  - Returns: Boolean indicating success

### Rule Generation Functions

```python
from admin.security.incident_response_kit import rule_generator
```

- **`create_yara_rule()`** - Generate YARA rule from malware sample
  - Parameters:
    - `sample_path`: Path to malware sample
    - `rule_name`: Name for the generated rule
    - `author`: Rule author
    - `description`: Rule description
    - `strings_min_length`: Minimum string length to include
    - `strings_max_count`: Maximum number of strings to include
    - `include_file_characteristics`: Whether to include file characteristics
  - Returns: String containing YARA rule

- **`create_network_rule()`** - Generate network detection rule
  - Parameters:
    - `pcap_file`: Path to packet capture file
    - `rule_type`: Type of rule to generate (snort, suricata, etc.)
    - `msg`: Rule message
    - `sid`: Signature ID
    - `rev`: Revision number
  - Returns: String containing network detection rule

## Best Practices & Security

- **Environment Isolation**: Always maintain strict isolation of analysis environment
- **Evidence Preservation**: Maintain chain of custody and evidence integrity at all times
- **Safe Handling**: Follow safe handling procedures for all malware samples
- **Containment Priority**: Focus on containment before extensive analysis in active incidents
- **Analysis Depth**: Match analysis depth to incident severity and resource constraints
- **Tool Security**: Regularly update and verify analysis tools
- **Secondary Confirmation**: Verify critical findings with multiple tools or approaches
- **Documentation Diligence**: Document all analysis steps and findings thoroughly
- **Tool Integrity**: Verify analysis toolkit integrity before each use
- **Information Security**: Apply appropriate classification to all analysis artifacts
- **Indicator Quality**: Focus on high-confidence indicators with low false positive rates
- **Context Preservation**: Maintain contextual information for all indicators
- **Analysis Limitations**: Document limitations and constraints of analysis
- **Legal Compliance**: Ensure analysis activities comply with legal and policy requirements
- **Data Protection**: Secure all analysis data with appropriate controls

## Related Documentation

- Incident Response Plan - Overall incident response process
- Malware Incident Response Playbook - Detailed malware response procedures
- Evidence Collection Guide - Procedures for collecting evidence
- Chain of Custody Template - Template for documenting evidence handling
- Malware Sample Handling Guidelines - Safe handling procedures for malware
- YARA Rule Development Guide - Guide for developing YARA rules
- Network Traffic Analysis Guide - Guide for network traffic analysis
- Threat Intelligence Integration - Integration with threat intelligence
- [MITRE ATT&CK Framework](https://attack.mitre.org/) - Framework for adversary tactics and techniques
- [NIST SP 800-61: Computer Security Incident Handling Guide](https://csrc.nist.gov/publications/detail/sp/800-61/rev-2/final)
- [NIST SP 800-86: Guide to Integrating Forensic Techniques into Incident Response](https://csrc.nist.gov/publications/detail/sp/800-86/final)
- [CISA Malware Analysis Report Guidelines](https://www.cisa.gov/sites/default/files/publications/MAR_10_GUI_v1_White.pdf)
