#!/bin/bash
# Malware Analysis Script for Forensic Analysis Toolkit
#
# This script provides a controlled environment for analyzing potentially malicious files.
# It handles various file types, runs static and dynamic analysis, and generates reports
# while maintaining forensic integrity through proper chain of custody.

set -eo pipefail

# --- Configuration ---
SCRIPT_DIR="$(cd "$(dirname "${BASH_SOURCE[0]}")" && pwd)"
PROJECT_ROOT="$(cd "$(dirname "$(dirname "$SCRIPT_DIR")")" && pwd)"

# Default settings
DEFAULT_OUTPUT_DIR="$PROJECT_ROOT/evidence/malware_analysis"
DEFAULT_SANDBOX_TIME="5m"
DEFAULT_YARA_RULES_DIR="$SCRIPT_DIR/static_analysis/common/yara_rules"
DEFAULT_LOG_LEVEL="INFO"

# Analysis settings
ANALYSIS_TIMEOUT=1800  # 30 minutes max for analysis
MEMORY_DUMP_ENABLED=true
NETWORK_CAPTURE_ENABLED=true
SCREENSHOT_ENABLED=true
NETWORK_SIMULATION_ENABLED=false

# --- Variables to be set by arguments ---
OUTPUT_DIR=""
TARGET_FILE=""
SANDBOX_TIME=""
YARA_RULES_DIR=""
GENERATE_REPORT=true
CASE_ID=""
EVIDENCE_ID=""
ANALYST=""
LOG_LEVEL=""
REPORT_TEMPLATE="$SCRIPT_DIR/templates/analysis_docs/malware_report.md"

# --- Functions ---

# Print usage information
usage() {
    cat << EOF
Usage: $(basename "$0") --file FILE [OPTIONS]

Analyze potentially malicious files in an isolated environment.

Required:
  --file FILE               Path to the file for analysis

Options:
  --output DIR              Output directory for analysis artifacts (default: $DEFAULT_OUTPUT_DIR)
  --sandbox-time TIME       Time limit for dynamic analysis (default: $DEFAULT_SANDBOX_TIME)
  --yara-rules DIR          Custom YARA rules directory (default: $DEFAULT_YARA_RULES_DIR)
  --no-report               Don't generate analysis report
  --case-id ID              Case identifier for evidence tracking
  --evidence-id ID          Evidence identifier for chain of custody
  --analyst NAME            Name of analyst performing the examination
  --network-simulation      Enable internet simulation for malware
  --no-memory-dump          Disable memory dumping during analysis
  --no-network-capture      Disable network traffic capture
  --log-level LEVEL         Logging level (DEBUG, INFO, WARN, ERROR)
  --verbose                 Enable verbose output
  --help                    Display this help message and exit

Examples:
  $(basename "$0") --file suspicious.exe --output /evidence/case123 --case-id CASE-2024-001
  $(basename "$0") --file unknown.doc --sandbox-time 10m --network-simulation
EOF
    exit 1
}

# Log messages with timestamp and level
log() {
    local level="$1"
    local message="$2"
    local timestamp=$(date -u "+%Y-%m-%d %H:%M:%S UTC")

    # Skip if log level is too verbose
    case "$LOG_LEVEL" in
        ERROR)
            [[ "$level" == "ERROR" ]] || return 0;;
        WARN)
            [[ "$level" == "ERROR" || "$level" == "WARN" ]] || return 0;;
        INFO)
            [[ "$level" == "DEBUG" ]] && return 0;;
        DEBUG)
            :;; # Log everything
    esac

    # Format with color based on level
    case "$level" in
        ERROR) echo -e "\033[1;31m[$timestamp] ERROR: $message\033[0m" >&2;;
        WARN)  echo -e "\033[1;33m[$timestamp] WARN: $message\033[0m" >&2;;
        INFO)  echo -e "\033[1;32m[$timestamp] INFO: $message\033[0m";;
        DEBUG) echo -e "\033[1;36m[$timestamp] DEBUG: $message\033[0m";;
        *)     echo -e "[$timestamp] $level: $message";;
    esac

    # Write to log file if specified
    if [[ -n "$LOG_FILE" ]]; then
        echo "[$timestamp] $level: $message" >> "$LOG_FILE"
    fi
}

log_info() { log "INFO" "$1"; }
log_warn() { log "WARN" "$1"; }
log_error() { log "ERROR" "$1"; }
log_debug() { log "DEBUG" "$1"; }

# Verify file exists and is readable
verify_file() {
    if [[ ! -f "$1" ]]; then
        log_error "File not found: $1"
        exit 1
    fi

    if [[ ! -r "$1" ]]; then
        log_error "File is not readable: $1"
        exit 1
    }

    log_debug "File verified: $1"
}

# Create chain of custody entry
create_coc_entry() {
    local action="$1"
    local details="$2"
    local coc_file="$OUTPUT_DIR/chain_of_custody.jsonl"

    # Create CoC file with header if it doesn't exist
    if [[ ! -f "$coc_file" ]]; then
        cat > "$coc_file" << EOF
# Chain of Custody Log
# File: $(basename "$TARGET_FILE")
# Case ID: $CASE_ID
# Evidence ID: $EVIDENCE_ID
# Analysis started: $(date -u "+%Y-%m-%d %H:%M:%S UTC")
EOF
    fi

    # Append entry
    cat >> "$coc_file" << EOF
{"timestamp":"$(date -u "+%Y-%m-%dT%H:%M:%SZ")","action":"$action","details":"$details","analyst":"$ANALYST"}
EOF

    log_debug "Chain of custody entry added: $action"
}

# Calculate file hashes (MD5, SHA-1, SHA-256)
calculate_hashes() {
    local file_path="$1"
    local output_file="$2"

    log_info "Calculating hashes for: $(basename "$file_path")"

    {
        echo "File: $(basename "$file_path")"
        echo "Path: $file_path"
        echo "Size: $(stat -f %z "$file_path") bytes"
        echo "MD5: $(md5 -q "$file_path")"
        echo "SHA-1: $(shasum -a 1 "$file_path" | awk '{print $1}')"
        echo "SHA-256: $(shasum -a 256 "$file_path" | awk '{print $1}')"
        echo "Analysis time: $(date -u "+%Y-%m-%d %H:%M:%S UTC")"
    } > "$output_file"

    log_debug "Hash calculation complete, saved to: $output_file"
}

# Run static analysis on the file
run_static_analysis() {
    log_info "Starting static analysis..."
    create_coc_entry "static_analysis_start" "Beginning static analysis of file"

    local static_dir="$OUTPUT_DIR/static_analysis"
    mkdir -p "$static_dir"

    # Calculate and record file hashes
    calculate_hashes "$TARGET_FILE" "$static_dir/hashes.txt"

    # Run file analyzer
    if command -v python3 &>/dev/null && [[ -f "$SCRIPT_DIR/static_analysis/file_analyzer.py" ]]; then
        log_info "Running file analysis..."
        python3 "$SCRIPT_DIR/static_analysis/file_analyzer.py" \
            --file "$TARGET_FILE" \
            --full-analysis \
            --extract-resources \
            --extract-strings \
            --detect-obfuscation \
            --output "$static_dir/file_analysis.json" \
            --case-id "$CASE_ID" \
            --analyst "$ANALYST" \
            --evidence-id "$EVIDENCE_ID" || log_warn "File analysis failed"
    else
        log_warn "File analyzer not found, skipping detailed file analysis"
    fi

    # Run signature checker
    if command -v python3 &>/dev/null && [[ -f "$SCRIPT_DIR/static_analysis/signature_checker.py" ]]; then
        log_info "Running signature checks..."
        python3 "$SCRIPT_DIR/static_analysis/signature_checker.py" \
            --file "$TARGET_FILE" \
            --full-analysis \
            --yara-rules "$YARA_RULES_DIR" \
            --output "$static_dir/signature_check.json" \
            --case-id "$CASE_ID" \
            --analyst "$ANALYST" \
            --evidence-id "$EVIDENCE_ID" || log_warn "Signature check failed"
    else
        log_warn "Signature checker not found, skipping malware signature checks"
    fi

    # Extract strings for basic analysis
    strings "$TARGET_FILE" > "$static_dir/strings.txt"

    # Extract metadata with exiftool if available
    if command -v exiftool &>/dev/null; then
        log_info "Extracting file metadata..."
        exiftool -json "$TARGET_FILE" > "$static_dir/metadata.json" || log_warn "Metadata extraction failed"
    fi

    create_coc_entry "static_analysis_complete" "Completed static analysis of file"
    log_info "Static analysis completed"
}

# Prepare sandbox environment for dynamic analysis
prepare_sandbox() {
    log_info "Preparing sandbox environment..."
    create_coc_entry "sandbox_preparation" "Setting up isolated environment for dynamic analysis"

    local sandbox_dir="$OUTPUT_DIR/dynamic_analysis"
    mkdir -p "$sandbox_dir"

    # Check for virtualization or container tools
    local sandbox_type="none"
    if command -v docker &>/dev/null; then
        sandbox_type="docker"
    elif command -v vboxmanage &>/dev/null; then
        sandbox_type="virtualbox"
    elif command -v qemu-img &>/dev/null; then
        sandbox_type="qemu"
    fi

    # Record sandbox configuration
    cat > "$sandbox_dir/environment.json" << EOF
{
    "sandbox_type": "$sandbox_type",
    "network_simulation": $NETWORK_SIMULATION_ENABLED,
    "memory_dump": $MEMORY_DUMP_ENABLED,
    "network_capture": $NETWORK_CAPTURE_ENABLED,
    "analysis_timeout": "$SANDBOX_TIME",
    "prepared_at": "$(date -u "+%Y-%m-%dT%H:%M:%SZ")"
}
EOF

    log_debug "Sandbox environment prepared ($sandbox_type)"
    return 0
}

# Run dynamic analysis in sandbox environment
run_dynamic_analysis() {
    log_info "Starting dynamic analysis..."
    create_coc_entry "dynamic_analysis_start" "Beginning dynamic analysis of file"

    # Prepare sandbox environment
    prepare_sandbox

    local dynamic_dir="$OUTPUT_DIR/dynamic_analysis"
    local sandbox_type=$(jq -r '.sandbox_type' "$dynamic_dir/environment.json")

    # For this script version, we'll simulate dynamic analysis
    # In a real implementation, this would use appropriate sandboxing technology

    if [[ "$sandbox_type" == "none" ]]; then
        log_warn "No sandboxing technology available, simulating dynamic analysis"

        # Simulate analysis for documentation purposes
        cat > "$dynamic_dir/simulated_analysis.txt" << EOF
SIMULATED DYNAMIC ANALYSIS
==========================
Analysis Time: $(date -u "+%Y-%m-%d %H:%M:%S UTC")
Target File: $(basename "$TARGET_FILE")
Analysis Duration: $SANDBOX_TIME

This is a placeholder for actual dynamic analysis results.
In a production environment, this script would:
1. Deploy the sample to an isolated sandbox environment
2. Execute the file with appropriate monitoring
3. Capture system changes, network traffic, and behaviors
4. Generate reports on observed malicious activities

NO ACTUAL EXECUTION OCCURRED.
EOF
        sleep 2  # Simulate brief analysis time
    else
        # Implementation for actual sandbox execution would go here
        # This is a placeholder for sandbox-specific code
        log_info "Using $sandbox_type for dynamic analysis"
        log_info "Running with $SANDBOX_TIME timeout"

        # Placeholder for actual execution code
        sleep 3  # Simulate analysis time
    fi

    create_coc_entry "dynamic_analysis_complete" "Completed dynamic analysis of file"
    log_info "Dynamic analysis completed (simulated)"
}

# Generate final analysis report
generate_report() {
    log_info "Generating analysis report..."
    create_coc_entry "report_generation" "Creating comprehensive analysis report"

    local report_file="$OUTPUT_DIR/malware_analysis_report.md"

    # Get basic file information
    local file_name=$(basename "$TARGET_FILE")
    local file_size=$(stat -f %z "$TARGET_FILE")
    local md5=$(md5 -q "$TARGET_FILE")
    local sha256=$(shasum -a 256 "$TARGET_FILE" | awk '{print $1}')
    local file_type=$(file -b "$TARGET_FILE")

    # Start with template if available
    if [[ -f "$REPORT_TEMPLATE" ]]; then
        cp "$REPORT_TEMPLATE" "$report_file"

        # Replace template variables with actual values
        sed -i '' "s/{{case_id}}/$CASE_ID/g" "$report_file"
        sed -i '' "s/{{evidence_id}}/$EVIDENCE_ID/g" "$report_file"
        sed -i '' "s/{{analyst_name}}/$ANALYST/g" "$report_file"
        sed -i '' "s/{{creation_date}}/$(date -u "+%Y-%m-%d")/g" "$report_file"
        sed -i '' "s/{{last_updated}}/$(date -u "+%Y-%m-%d")/g" "$report_file"
        sed -i '' "s/{{original_filename}}/$file_name/g" "$report_file"
        sed -i '' "s/{{file_size}}/$file_size bytes/g" "$report_file"
        sed -i '' "s/{{file_type}}/$file_type/g" "$report_file"
        sed -i '' "s/{{md5_hash}}/$md5/g" "$report_file"
        sed -i '' "s/{{sha256_hash}}/$sha256/g" "$report_file"
    else
        # Create a basic report if template is not available
        cat > "$report_file" << EOF
# Malware Analysis Report

**Case ID:** $CASE_ID
**Evidence ID:** $EVIDENCE_ID
**Analyst:** $ANALYST
**Date:** $(date -u "+%Y-%m-%d")

## Sample Information

**Filename:** $file_name
**File Size:** $file_size bytes
**File Type:** $file_type
**MD5:** $md5
**SHA-256:** $sha256

## Analysis Summary

*This report was automatically generated by the Forensic Analysis Toolkit.*
*Manual review and completion of analysis findings is required.*

### Static Analysis Results

Static analysis artifacts are available in: \`$OUTPUT_DIR/static_analysis/\`

### Dynamic Analysis Results

Dynamic analysis artifacts are available in: \`$OUTPUT_DIR/dynamic_analysis/\`
EOF
    fi

    # Generate HTML version if pandoc is available
    if command -v pandoc &>/dev/null; then
        pandoc -s "$report_file" -o "${report_file%.md}.html" || log_warn "Failed to generate HTML report"
    fi

    log_info "Analysis report generated: $report_file"
    create_coc_entry "report_complete" "Analysis report generated"
}

# Parse command-line arguments
parse_arguments() {
    # Set defaults
    OUTPUT_DIR="$DEFAULT_OUTPUT_DIR"
    SANDBOX_TIME="$DEFAULT_SANDBOX_TIME"
    YARA_RULES_DIR="$DEFAULT_YARA_RULES_DIR"
    LOG_LEVEL="$DEFAULT_LOG_LEVEL"

    # Parse arguments
    while [[ $# -gt 0 ]]; do
        case "$1" in
            --file)
                TARGET_FILE="$2"
                shift 2
                ;;
            --output)
                OUTPUT_DIR="$2"
                shift 2
                ;;
            --sandbox-time)
                SANDBOX_TIME="$2"
                shift 2
                ;;
            --yara-rules)
                YARA_RULES_DIR="$2"
                shift 2
                ;;
            --no-report)
                GENERATE_REPORT=false
                shift
                ;;
            --case-id)
                CASE_ID="$2"
                shift 2
                ;;
            --evidence-id)
                EVIDENCE_ID="$2"
                shift 2
                ;;
            --analyst)
                ANALYST="$2"
                shift 2
                ;;
            --network-simulation)
                NETWORK_SIMULATION_ENABLED=true
                shift
                ;;
            --no-memory-dump)
                MEMORY_DUMP_ENABLED=false
                shift
                ;;
            --no-network-capture)
                NETWORK_CAPTURE_ENABLED=false
                shift
                ;;
            --log-level)
                LOG_LEVEL="$2"
                shift 2
                ;;
            --verbose)
                LOG_LEVEL="DEBUG"
                shift
                ;;
            --help)
                usage
                ;;
            *)
                log_error "Unknown option: $1"
                usage
                ;;
        esac
    done

    # Validate required arguments
    if [[ -z "$TARGET_FILE" ]]; then
        log_error "No target file specified"
        usage
    fi

    # Create absolute paths
    TARGET_FILE=$(realpath "$TARGET_FILE")
    OUTPUT_DIR=$(realpath "$OUTPUT_DIR")

    # Use timestamp in output directory if needed
    if [[ -z "$CASE_ID" ]]; then
        TIMESTAMP=$(date +"%Y%m%d_%H%M%S")
        OUTPUT_DIR="${OUTPUT_DIR}/analysis_${TIMESTAMP}"
    else
        OUTPUT_DIR="${OUTPUT_DIR}/${CASE_ID}"
    fi

    # Set default analyst if not specified
    if [[ -z "$ANALYST" ]]; then
        ANALYST="$(whoami)"
    fi

    # Create log file
    LOG_FILE="$OUTPUT_DIR/analysis.log"
}

# Main function
main() {
    # Parse command-line arguments
    parse_arguments "$@"

    # Verify the target file
    verify_file "$TARGET_FILE"

    # Create output directory
    mkdir -p "$OUTPUT_DIR"

    # Initialize logging
    touch "$LOG_FILE"

    log_info "=== Malware Analysis Started ==="
    log_info "Target file: $TARGET_FILE"
    log_info "Output directory: $OUTPUT_DIR"

    # Record basic information
    create_coc_entry "analysis_start" "Started analysis of file: $(basename "$TARGET_FILE")"

    # Run analysis phases
    run_static_analysis
    run_dynamic_analysis

    # Generate report if requested
    if [[ "$GENERATE_REPORT" == true ]]; then
        generate_report
    fi

    create_coc_entry "analysis_complete" "Analysis completed successfully"
    log_info "=== Malware Analysis Completed ==="
    log_info "Results saved to: $OUTPUT_DIR"

    return 0
}

# Execute main function with all arguments
main "$@"
